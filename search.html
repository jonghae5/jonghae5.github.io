<!DOCTYPE html>
<html>
  <head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>
      Search Result
    </title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/built/screen.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/built/screen.edited.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/built/syntax.css"
    />

    <!-- Custom CSS -->
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/built/custom.css"
    />

    <!-- Font awesome -->
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
    />

    <!-- 웹폰트 추가 -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300&display=swap"
    />

    <!-- Syntax CSS -->
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/built/syntax.css"
    />

    <!-- highlight.js -->
    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"
    />
    <style>
      .hljs {
        background: none;
      }
    </style>

    <!--[if IE]>
      <style>
        p,
        ol,
        ul {
          width: 100%;
        }
        blockquote {
          width: 100%;
        }
      </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="AI & Frontend Developer" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="John's IT Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="AI & Frontend Developer" />
    <meta property="og:url" content="http://localhost:4000/search" />
    <meta property="og:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="AI & Frontend Developer" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="John's IT Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "John's IT Blog",
        "logo": "http://localhost:4000/"
    },
    "url": "http://localhost:4000/search",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/search"
    },
    "description": "AI & Frontend Developer"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />

  </head>
  <body
    class="page-template"
  >
    <div class="site-wrapper">
      <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
      <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/">John's IT Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-ai" role="menuitem"><a href="/tag/data/">Data</a></li>
    <li class="nav-frontend" role="menuitem"><a href="/tag/frontend/">Frontend</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "cnn-basic-8": {
        "title": "합성곱 신경망 기초 8(데이터 증강, Data Augmentation)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  Data Augmentation이란?  Data Augmentation은 데이터의 양을 늘리기 위해 원본에 각종 변환을 적용하여 충분히 학습에 활용될 수 있는 데이터 개수를 증강시키는 기법이다.  CNN은 영상의 2차원 변환인 회전(Rotation), 크기(Scale), 밀림(Shearing), 반사(Reflection), 이동(Translation)와 같은 2차원 변환인 Affine Transform에 취약하다.  즉, Affine Tranform으로 변환된 영상은 다른 영상으로 인식한다.  또한 Noise삽입, 색상, 밝기 변형 등을 활용하여 Data Augmentation 효과를 얻을 수 있다.어떻게 Data Augumentation이 나왔을까?      Augmenation 기술은 사실 많이 활용되던 기술이 아니다. 이는 알고리즘적인 해결방법이 아니라, 순수한 공학적 접근을 통한 추론을 위한 전처리 기술 중 하나였다.    딥러닝의 고질적인 문제는 여러가지 있는데, 그 중 대표적인 문제가 Overfitting이다. 과거 Overfitting을 해결하기 위해 익히 알고있는 모델링 수정 Regularization, Normalization을 활용했다.  하지만, 이와 같은 Overfitting을 해결 방법은 편향 학습 방향을 조금 죽이는 정도다. 따라서 결과적으로 우리가 원하는 Overfitting을 해결하는 기술이 되진 않았다.👉 공학적 방법으로 학습의 방향성을 상하좌우 더 넓힐 수 있는 방법이 없을지 고민하게 된다. 단순히 편향된 학습은 오류를 발생시키지만,여기서의 목적은 적당한 힘으로 학습을 아주 조금 골고루 넓히자는 의미이다.방법론에는 Image Manipulation, Generative Model,AutoML 기반 방법론 등 다양한게 있지만 주요 방법론인 Image Manipulation 기반을 살펴보자.Image Manipulation 기반 방법론Pixel-Level Transforms  우선 Pixel 단위로 변환을 시키는 Pixel-Level Transform은 대표적으로 Blur, Jitter, Noise 등을 이미지에 적용하는 기법이다.  Gaussian Blur, Motion Blur, Brightness Jitter, Contrast Jitter, Saturation Jitter, ISO Noise, JPEG Compression 등 다양한 기법이 사용된다.Spatial-Level Transforms  Image 자체를 변화시키는 Spatial-Level Transform으로, 대표적으로 Flip과 Rotation이 있으며, Image의 일부 영역을 잘라내는 Crop도 많이 사용한다.  주의해야할 점은 Detection (Bounding Box), Segmentation (Mask) Task의 경우 Image에 적용한 Transform을 GT에도 동일하게 적용을 해줘야 하고, Classification의 경우 적용하였을 때 Class 가 바뀔 수 있음을 고려하여 적용해야 한다. (Ex, 6을 180도 회전하면 9)“MixUp: Beyond Empirical Risk Minimization”, 2018  두 image와 Label을 0~1 사이의 lambda 값을 통해 Weighted Linear Interpolation 해주는 기법이다.  보통 lambda 값은 beta distribution을 통해 뽑아낸다. 이 방법은 굉장히 단순하지만 모델의 일반화 성능도 좋아지고 corrupt label의 memorization을 방지해주고, adversarial example에 sensitive해지는 등 다양한 효과를 얻을 수 있다.“CutMix: Regularization Strategy to Train Strong Classifiers with Localizable Features”, 2019  우리 나라 연구 성과인 CutMix, MixUp은 두 image를 섞는 방식이고, Cutout은 image의 box를 쳐서 지우는 방식이었다면, CutMix는 두 방법을 합친 방법이다.  이미지 데이터를 Convex combination하여 새로운 데이터를 만드는 것으로 클래스가 다른 이미지들도 mixup하여 label 또한 mixup을 한다는 것이다.  원본 image에서 box를 쳐서 지운 다음 그 빈 영역을 다른 image로부터 patch를 추출하여 집어넣는다. Patch의 면적에 비례하여 Label도 섞어주는 방식이다.  이 방법을 적용하면 실제로 데이터 모델링시 성능이 많이 좋아지는 경우가 많다고 한다.결론  Data augmentation의 경우 over fitting을 방지하기 위한 여러 기술 중 하나로 발전되고 있다.  Over fitting은 알고리즘의 Variance가 클 때 발생하는 문제로, train data set에 대해 learning을 정상적으로 마친 후 test data set에 적용할 때 그 결과가 매우 다르게 나온다는 것을 의미한다.  이러한 Over fitting을 방지하기 위해 Variance를 낮추는 방법으로는 training data를 많이 모으는 방법, feature의 개수를 줄이는 방법, regularization을 통해 weight 값을 조절해주는 방법 등이 있다.  여기에서 training data를 많이 모으는 방법은 금전적, 시간적으로 손실이 큰데, 이를 해결하기 위한 기존에 있는 Data를 활용하여 변형하는 방법이 Data augmentation이다.참조 문헌[1] A survey on Image Data Augmentation for Deep Learning, 2019https://journalofbigdata.springeropen.com/articles/10.1186/s40537-019-0197-0",
        "url": "/cnn-basic-8"
    }
    ,
    
    "js-basic-19": {
        "title": "클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수, Closure)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  함수 다루기 😎Callback Function👍  함수의 실행권을 다른 함수에 유임한다.someElement.addEventListener('click',function() {//..somecode})DOM.prototype.addEventListener = function (eventType, cbFunc) {  if (eventType === \"click\") {    const clickEventObject = {      target: {},    };    cbFunc(clickEventObject);  }};function register() {  const isConfirm = confirm(\"회원가입에 성공했습니다.\");  if (isConfirm) {    redirectUserInfoPage();  }}function login() {  const isConfirm = confirm(\"로그인에 성공했습니다.\");  if (isConfirm) {    redirectIndexPage();  }}// 리팩토링function confirmModal(message, cbFunc) {  const isConfirm = confirm(message);  if (isConfirm &amp;&amp; cbFunc) {    cbFunc();  }}function register() {  confirmModal(\"회원가입에 성공했습니다.\", redirectUserInfoPage);}function login() {  confirmModal(\"로그인에 성공했습니다.\", redirectIndexPage);}순수 함수👍let num1 = 10;let num2 = 20;function impureSum1() {  return num1 + num2;}function impureSum2() {  return num1 + newNum;}impureSum1(); // 30num1 = 30;impureSum1(); // 50// 함수는 동일한 인자를 받고 동일한 출력을 해야한다.// 외부 조작으로 인해 고유한 일관성이나 값, 매개변수를 받고 있지 않음// 함수 사용시, 예측이 안되는 것 &gt; 비순수한 함수impureSum1(20); // 50impureSum1(30); // 60num1 = 100;impureSum1(20); // 120impureSum1(30); // 130function pureSum(num1, num2) {  return num1 + num2;}pureSum(10, 20); // 30pureSum(30, 20); // 50function changeValue(num) {  num++;  return num;}changeValue(1); //2changeValue(4); //5const obj = { one: 1 };function changeObj(targetObj) {  targetObj.one = 100;  return targetObj;}chagneObj(obj); // { one : 100 }obj; // { one : 100 }// 객체는 일반 primitive type 값과 다르게 작동한다.// 객체 및 배열 =&gt; 새롭게 만들어서 반환const obj2 = { one: 1 };function changeObj2(targetObj) {  return { ...targetObj, one: 100 };}chagneObj(obj2); // { one : 100 }obj2; // { one : 1 }Closure👍function add(num1) {  return function sum(num2) {    return num1 + num2;  };}const addOne = add(1); // sum(1,num2)const addTwo = add(2); // sum(2,num2)function sum1(num1, num2) {  return num1 + num2;}function mul1(num1, num2) {  return num1 * num2;}const addThree = add(5)(2); // 값을 캡쳐하고 있는 상태const sumAdd = addThree(sum1); // 7const sumAdd = addThree(mul1); // 10function log(value) {  return function (fn) {    fn(value);  };}const logFoo = log(\"foo\");logFoo((v) =&gt; console.log(v));logFoo((v) =&gt; console.info(v));logFoo((v) =&gt; console.error(v));logFoo((v) =&gt; console.warn(v));const arr = [1, 2, 3, \"A\", \"B\", \"C\"];const isNumber = (value) =&gt; {  typeof value === \"number\";};const isString = (value) =&gt; {  typeof value === \"string\";};arr.filteR(isNumber);// 함수 사용function isTypeOf(type, value) {  return typeof value === type;}const isNumber1 = (value) =&gt; {  isTypeOf(\"number\", value);};const isString1 = (value) =&gt; {  isTypeOf(\"string\", value);};// Closure 사용function isTypeOf2(type) {  return function (value) {    return typeof value === type;  };}const isNumber2 = isTypeOf2(\"number\");const isString2 = isTypeOf2(\"string\");arr.filter(isNumber2); // [1,2,3]arr.filter(isString2); // ['A','B','C']function fetcher(endpoint) {  return function (url, options) {    return fetch(endpoint + url, options)      .then((res) =&gt; {        if (res.ok) {          return res.json();        } else {          throw new Error(res.error);        }      })      .catch((err) =&gt; console.error(err));  };}const naverApi = fetcher(\"http://naver.com/\");const daumApi = fetcher(\"http://daum.net/\");naverApi(\"/webtoon\").then((res) =&gt; res);daumApi(\"/webtoon\").then((res) =&gt; res);someElement.addEventListener(\"click\", debounce(handleClick, 500));",
        "url": "/js-basic-19"
    }
    ,
    
    "js-basic-18": {
        "title": "클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters, void &amp; return, 화살표 함수)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  함수 다루기 😎default value👍function createCarousel(options) {  var options = options || {};  var margin = options.margin || 0;  var center = options.center || false;  var navElement = options.navElement || \"div\";  return {    margin,    center,    navElement,  };}// 객체 구조 분해 이용function createCarousel2({  margin = 0,  center = false,  navElement = \"div\",} = {}) {  return {    margin,    center,    navElement,  };}createCarousel(); // default valuecreateCarousel2(); // default value  default parameter 적용const required = (argName) =&gt; {  throw new Error(\"required is \" + argName);};function createCarousel({  items = required(\"items\"),  margin = 0,  center = false,  navElement = \"div\",} = {}) {  return {    margin,    center,    navElement,  };}console.log(createCarousel({ center: true, navElement: \"span\" })); // \"required is items\"Rest Parameters👍  나머지 매개변수는 가장 마지막에 들어가야 한다.  인자가 가변적으로 들어올 때 유용하다.  유사배열객체가 아닌 배열로 사용 가능하다.function sumTotal() {  typeof arguments; //object  Array.isArray(arguments); // false  return Array.from(args).reduce((acc, curr) =&gt; acc + curr);}sumTotal(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);// Rest Parameter로 들어온 것은 배열로 사용 가능function sumTotal2(initialValue, bonusValue, ...args) {  Array.isArray(args); // true  console.log(initialValue); // 100  console.log(bonusValue); // 1000  return args.reduce((acc, curr) =&gt; acc + curr);}sumTotal2(100, 1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);void &amp; return👍  void는 undefined를 return 한다.  return을 쓰지 않아도 되는데 굳이 사용하는 것을 방지하자.function handleClick() {  return setState(false);}function showAlert(message) {  return alert(message);}// 개선function handleClick2() {  setState(false);}function showAlert2(message) {  alert(message);}function test(sum1, sum2) {  const result = sum1 + sum2;}console.log(test(1, 2)); // undefinedfunction testVoidFunc() {  return test(1, 2);}console.log(testVoidFunc()); // undefined  return이 있는 함수 =&gt; get…, is…function isAdult(age) {  return age &gt; 19;}function getUserName(name) {  return \"유저 \" + name;}const isFlag = isAdult(10);console.log(isFlag); // false화살표 함수(Arrow Function)👍  렉시컬 스코프를 바라보게 된다.  객체를 바라보지 않고 상위 문맥을 따르는 경우가 있다.  this 사용시 화살표 함수를 주의해야한다.const user = {  name: \"Poco\",  getName: () =&gt; {    return this.name;  },};console.log(user.getName()); // undefinedconst user2 = {  name: \"Poco\",  getName() {    return this.name;  },};console.log(user2.getName()); // Pococonst user = {  name: \"Poco\",  getName: () =&gt; {    return this.name;  },  newFriends: () =&gt; {    // call, apply, bind 사용X    const newFriendList = Array.from(arguments);    return this.name + newFriendList;  },};const user2 = {  name: \"Poco\",  getName: () =&gt; {    return this.name;  },  newFriends: (...rest) =&gt; {    return this.name + rest;  },};const Person = (name, city) =&gt; {  this.name = name;  this.city = city;};const person = new Person(\"poco\", \"korea\"); // Person is not a constructorclass Parent {  parentMethod() {    console.log(\"parentMethod\");  }  parentMethodArrow = () =&gt; {    console.log(\"parentMethodArrow\");  };  overrideMethod = () =&gt; {    return \"parent\";  };}class Chiled extends Parent {  chileMethod() {    super.parentMethodArrow();  }  overrideMethod() {    return \"Child\";  }}new Child().childMethod(); // Error 발생, 생성자 함수 내부에서 초기화가 되는 현상 발생new Child().overrideMethod(); // 'Parent' 부모 메서드 호출function* gen() {  yield () =&gt; ?? //문법적으로 지원 X}function* gen() {  yield function hello() {    //... some Code  }}주의할 점🌼  this 동작 방식  Class 입장에서의 Override, 부모 메서드 응용 단계  new 산자 조합 X  arguments, call, apply, bind X  React ,Vue 등 라이브러리말고 Vanilla JS 사용시 주의 필요!",
        "url": "/js-basic-18"
    }
    ,
    
    "js-basic-17": {
        "title": "클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp; parameter,복잡한 인자 관리하기)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  함수 다루기 😎함수, 메서드, 생성자👍 1급 객체  변수나, 데이터에 담길 수 있다.  매개변수로 전달 가능 (콜백 함수)  함수가 함수를 반환 (고차 함수)function func() {  return this;}// 객체 메서드const obj = {  conciseMethod() {    return this;  },};// 생성자 함수 (Class)function Func() {  return this;}// 전역을 바라본다func();// 메서드 =&gt; 객체에 의존성이 있는 함수, OOP 행동을 의미obj.method();//생성자 함수 =&gt; 인스턴스를 생성하는 역할 =&gt; Classconst instance = new Func();argument &amp; parameter👍  Parameter (Formal Parameter) : 형식을 갖춘, 매개변수  Arguments (Actual Parameter) : 실제로 사용되는, 인자function axios(url) {  // Parameter  // some code...}axios(\"https://github.com\"); //Arguments복잡한 인자 관리하기👍  무조건 3개 이상이 나쁜게 아니다.  맥락을 파악할 수 있으면 된다.function toggleDisplay(isToggle) {  // ..some code}function sum(sum1, sum2) {  // ..some code}sum(1, 2);function getRandomNumber(min, max) {  // ..some code}function timer(start, stop, end) {  // ..some code}function getSquare(top, right, bottom, left) {  // ..some code}function createCar1(name, brand, color, type) {  return {    name,    brand,    color,    type,  };}// 객체 이용function createCar2(options) {  var name = options.name;  var brand = options.brand;  var color = options.color;  var type = options.type;  return {    name: name,    brand: brand,    color: color,    type: type,  };}// 객체 구조 분해 할당function createCar3({ name, brand, type, color }) {  return {    name,    brand,    color,    type,  };}function createCar4(name, { brand, type, color }) {  return {    name,    brand,    color,    type,  };}createCar4(\"차량 이름\", {  /*...somecode*/});  에러를 띄어주는 인자관리방법function createCar({ name, brand, type, color }) {  if (!name) {    throw new Error(\"name is a required\");  }  if (!brand) {    throw new Error(\"brand is a required\");  }}",
        "url": "/js-basic-17"
    }
    ,
    
    "cnn-basic-7": {
        "title": "합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for Convolutional Neural Networks)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  EfficientNet  2019년 5월에 발표된 이 논문은 한정된 Resource에서 CNN을 깊이와 넓이 그리고 해상도의 밸런스를 조절할 수 있는 새로운 스케일 메소드를 제안  최근 CNN Architecture는 효율적인 Mobile-size ConvNet의 디자인이 인기가 많아지고, 수작업으로 만들어진 Mobile ConvNet보다 광범위하게 튜닝 가능한 것이 훨씬 더 나은 퍼포먼스를 도출  CNN에서의 Network의 깊이와 너비 그리고 이미지의 해상도의 관계를 정량화하여 나타냈다는 점에서 이 논문의 중요한 Key PointIntroduction      해상도(Resolution)          단순하게, 위 이미지에서 개를 인식한다고 했을 때, 우측처럼 큰 이미지일 수록 인식하기가 쉽다.      왜냐하면, 입력의 해상도가 작을수록 CNN을 거치면서 Convolution, Pooling이 진행됨에 따라 특징이 소실되거나, 추출되지 않는 경우가 발생하기 때문이다.            깊이(Depth)          이미지의 depth(layer 개수)를 늘릴수록 성능이 증가하는 것은 ResNet의 사례를 통해 알 수 있다.            넓이(Channel 개수)          네트워크의 넓이(Channel 개수, 혹은 layer 안의 연산)를 늘려서 성능이 좋아진 예시도 ResNet과 ResNext 논문을 비교해보면 알 수 있다.      ResNext는 네트워크의 한 레이어에서 레이어의 폭을 넓혀 진행한 것을 볼 수 있고, ResNet-50, ResNext-50을 비교했을 때 성능이 향상된 것을 확인할 수 있다.      EfficientNet은 이 점에 착안하여 세 요소들의 균형을 찾기 위한 실험을 진행했다.  기존 Network보다 파라미터 대비 정확도가 높은 효율적인 Network를 제시하였으며 효율적인 Network라는 이름을 본따 EfficientNet으로 정하였다.  위 사진을 보면 EfficientNet이 SOTA image classification network보다 효율적인 모델임을 알 수 있다.(B0~B7는 모델 사이즈를 의미)Compound Model Scaling본 논문에서는 어떻게 Network를 확장해야 효율적일지에 대한 연구가 진행되었고 아래에 그림처럼 기본 baseline 모델에서 (b) width (c) depth (d) resolution 관점에서의 scaling을 적절한 비율로 조합한 (e) compound scaling 모델을 제안한다.      Depth (d)          Network가 깊어지면 복잡한 특징을 추출할 수 있고 다른 task에 일반화하기 좋지만 vanishing gradient problem이 생기게 된다.      이를 해결하기위해 ResNet의 skip connection, batch normalization 등 다양한 방법들이 있지만 그렇다 하더라도 너무 깊은 Layer를 가진 모델의 성능은 더 좋아지지 않는다.        Width (w):          보통 Width(Channel)는 작은 모델을 만들기 위해 scale down(MobileNet 등)을 하는데에 사용되었다.      더 넓은 channel은 더 세밀한 특징을 추출할 수 있고 train하기가 더 쉽다. width의 증가에 따른 성능은 빠르게 saturate되는 현상이 있다.        Resolution (r)          높은 해상도의 이미지를 input으로 사용할때 모델은 더욱 세밀한 패턴을 학습할 수 있기 때문에 성능을 높이기 위해서 Resolution을 크게 가져가고 있다.      최근에는 480x480(GPipe) 600x600(object detection)의 size를 사용하고 있다. 하지만 마찬가지로 너무 큰 해상도는 효율적이지 않다.        위 그래프는 각각 width, depth, resolution을 키웠을 때의 FLOPS(Floating point Operation Per Second)와 Accuracy를 보여준다.  width, depth, resolution 모두 80% accuracy까지만 빠르게 saturate(포화)되고 그 이후로의 성능향상은 한계가 있을을 알 수 있다.  먼저 depth를 α, width를 β, resolution을 γ로 만들고 ϕ=1 일때의 α x β^2 x γ^2 ≈ 2를 만족하는 α, β, γ를 grid search를 통해 찾는다. (논문에서 찾은 값은 α=1.2, β=1.1, γ=1.15 이다.)  여기서 width와 resolution에 제곱항이 있는 이유는 depth(Layer)가 2배 증가하면 FLOPS는 2배가 되지만 width와 resolution은 그렇지 않기 때문이다.  width는 이전 레이어의 출력, 현재 레이어의 입력 이렇게 두곳에서 연산이 이루어 지므로 width가 2배가 되면 4배의 FLOPS가 된다.  resolution은 가로 x세로 이기 때문에 당연히 resolution이 2배가 되면 4배의 FLOPS가 된다.  grid search를 통해 α, β, γ를 찾았다면 ϕ(0, 0.5, 1, 2, 3, 4, 5, 6)를 사용해 최종적으로 기존 width, depth, resolution에 곱할 factor를 만들게 된다.(파이의 변화로 B0~B7까지의 모델을 설계하였음)  위 그림은 scaling을 하지 않은 기본 B0모델 구조이다. Operator의 MBConv는 Mobilenet v2에서 제안된 inverted residual block을 의미하고 바로 옆에 1 혹은 6은 expand ratio이다.  ImageNet dataset의 size인 224x224를 input size로 사용하였다.  Activation function으로 ReLU가 아닌 Swish(혹은 SiLU(Sigmoid Linear Unit))를 사용하였다. Swish 는 매우 깊은 신경망에서 ReLU 보다 높은 정확도를 달성한다고 알려져있다.squeeze-and-excitation optimization 사용squeeze-and-excitation optimization  Squeeze? pooling을 통해 1x1 size로 줄여서 정보를 압축한 뒤에 excitation 즉 압축된 정보들을 weighted layer와 비선형 activation function으로 각 채널별 중요도를 계산하여 기존 input에 곱을 해주는 방식Experiments  비슷한 Top-1, Top-5 Accuracy를 보이는 기존의 ConvNet들을 묶어 EfficientNet과 비교한 것이다.  모든 영역에서 일관되게 EfficientNet이 훨씬 적은 parameter 수와 FLOPS를 보여주는 것을 알 수 있다.다음은 Class Activation Map(CAM)을 Network의 depth, width, resolution만 조정하여 설계하였을 때와 compound scaling을 활용하여 균형을 맞췄을 때의 CAM 비교 결과이다.참조 문헌[1]https://hoya012.github.io/blog/EfficientNet-review/[2]https://www.youtube.com/watch?v=Vhz0quyvR7I&amp;feature=youtu.be",
        "url": "/cnn-basic-7"
    }
    ,
    
    "js-basic-16": {
        "title": "클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기, hasOwnProperty, 직접 접근 지양하기)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  객체 다루기 😎Prototype 조작 지양하기👍  이미 JS는 많이 발전했다.          직접 만들어서 모듈화 =&gt; 배포 =&gt; NPM      JS 빌트인 객체를 건들지말자.      function Car {  this.name = name;  this.brand = brand;  Car.prototype.sayName = function () {    return this.brand + \"-\" + this.name;  }}class Car {  constructor(name, band) {    this.name = name;    this.brand = brand;  }  sayName() {    return this.brand + \"-\" + this.name;  }}const casper = new Car('캐스퍼','현대')String.prototpye.welcome = function () {  return \"hello\";};console.log(\"str\".welcome()); // 'hello' 매우 위험한 것Array.prototype.forEach = function () {  return \"hello\";};console.log([].forEach()); // 'hello'hasOwnProperty👍  다른 객체에 있는 hasOwnProperty를 불러올 수도 있다.  프로퍼티 명칭으로서 보호하지 않는다.const person = {  name: \"john\",};person.hasOwnProperty(\"name\"); // truefor (const key in object) {  if (Object.hasOwnProperty.call(object, key)) {    const element = object[key];  }}const foo = {  hasOwnProperty: function () {    return \"hasOwnProperty\";  },  bar: \"string\",};foo.hasOwnProperty('bar') // 'hasOwnProperty'console.log(Object.prototype.hasOwnProperty.call(foo.'bar')) // true// 함수를 따로 만들어 사용function hasOwnProp(targetObj,targetProp) { return Object.hasOwnProperty.call(targetObj, targetProp);}console.log(hasOwnProp(foo,'bar')); //true직접 접근 지양하기👍  예측 가능한 코드를 작성해서 동작이 예측 가능하게 앱 구현  getter, setterconst model = {  isLogin: false,  isValidToken: false,};function setLogin(bool) {  model.isLogin = bool;}function setValidToken(bool) {  model.isValidToken = bool;}// model에 대신 접근 O// function login() {//   model.isLogin = true;//   model.isValidToken = true;// }// function logout() {//   model.isLogin = false;//   model.isValidToken = false;// }// model에 대신 접근 Xfunction login() {  setLogin(true);  setValidToken(true);}function logout() {  setLogin(false);  setValidToken(false);}someElement.addEventListener(\"click\", login);",
        "url": "/js-basic-16"
    }
    ,
    
    "js-basic-15": {
        "title": "클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring, Object.freeze)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  객체 다루기 😎Object Destructuring👍function Person(name, age, location) {  this.name = name;  this.age = age;  this.location = location;}const john = new Perosn(\"john\", 30, \"Korea\");function Person({ name, age, location }) {  this.name = name;  this.age = age ?? 30;  this.location = location ?? \"korea\";}const john = new Perosn({  name: \"john\",  age: 30,  location: \"Korea\",});// name이 필수일 경우// 명시적 표현 가능function Person(name, { age, location }) {  this.name = name;  this.age = age ?? 30;  this.location = location ?? \"korea\";}const johnOptions = {  age: 30,  location: \"Korea\",};const john = new Perosn(\"poco\", johnOptions);const orders = [\"First\", \"Second\", \"Third\"];const st = orders[0];const rd = orders[2];console.log(st);console.log(rd);const [first, , third] = orders;console.log(first);console.log(third);// 생각보다 이런 경우가 많음const { 0: st2, 2: rd2 } = orders;console.log(st2);console.log(rd2);  Ex) React 경우function Welcome(props) {  return &lt;h1&gt;Hello {props.name} &lt;/h1&gt;;}// 객체 구조 분해 할당function Welcome2({ name }) {  return &lt;h1&gt;Hello {name} &lt;/h1&gt;;}Object.freeze👍const STATUS = Object.freeze({  PENDING: \"PENDING\",  SUCCESS: \"SUCCESS\",  FAIL: \"FAIL\",});STATUS.NEW_PROP = \"P2\";console.log(STATUS); // PENDING: \"PENDING\",SUCCESS: \"SUCCESS\",FAIL: \"FAIL\"Object.isFrozen(STATUS); // trueObject.isFrozen(STATUS.PENDING); // trueObject.isFrozen(STATUS.FAIL); // trueshallow copy vs deep copy  깊은 복사에는 관여를 못한다.const STATUS = Object.freeze({  PENDING: \"PENDING\",  SUCCESS: \"SUCCESS\",  FAIL: \"FAIL\",  OPTION: {    GREEN: \"GREEN\",    RED: \"RED\",  },});STATUS.OPTIONS.GREEN = \"G\";STATUS.OPTIONS.YELLOW = \"Y\";console.log(STATUS.OPTIONS); //     GREEN: \"GREEN\", RED: \"RED\", YELLOW:\"Y\"Object.isFrozen(STATUS.OPTIONS.GREEN); // false Deep Freezing 이 되지 않는다.중첩된 Freezing 해결 방법🌼  대중적인 유틸 라이브러리(lodash)  직접 유틸 함수 생성  stackoverflow  TypeScriptfunction deepFreeze(targetObj) {  // 1. 객체를 순회  // 2. 값이 객체인지 확인  // 3. 객체이면 재쉬  // 4. 그렇지 않으면 Object.freeze  Object.keys(targetObj).forEach(key =&gt; {    if(/*객체가 맞다면*/) {      deepFreeze();    }  })  return Object.freeze(targetObj);}",
        "url": "/js-basic-15"
    }
    ,
    
    "js-basic-14": {
        "title": "클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs forEach, continue&amp;break)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  배열 다루기 😎배열 메소드 체이닝 활용👍  요구사항이 많아질 때 배열 메소드 체이닝을 통해 클린코드를 구성할 수 있다.const price = [\"2000\", \"3000\", \"4000\", \"1000\", \"5000\"];const suffixWon = (price) =&gt; price + \"원\";const isOverOneThousand = (price) =&gt; Number(price) &gt; 1000;const ascendingList = (a, b) =&gt; a - b;function getWonPrice(priceList) {  return priceList    .filter(isOverOneThousand) // filter 원하는 조건에 맞는 배열 리스트 만드기    .sort(ascendingList) // sort 정렬    .map(suffixWon); // 배열 요소들을 다시 정리}const result = getWonPrice(price);map vs forEach👍return 이 있느냐 없느냐?  forEach          요소마다 함수를 실행시켜주는 역할      forEach 반환값 : undefined        map          함수 실행을 통해 배열 조작을 하는 역할      const prices = [\"1000\",\"2000\", \"3000\", \"4000\" \"5000\"];const newPricesForEach = prices.forEach(function (price) {  return price+'원';})const newPricesMap = prices.map(function (price) {  return price + '원'})console.log(newPricesForEach) // undefinedconsole.log(newPricesMap) // [\"1000원\",\"2000원\", \"3000원\", \"4000원\" \"5000원\"]  아래와 같을 때는 forEach가 더 유효하다.const prices = [\"1000\",\"2000\", \"3000\", \"4000\" \"5000\"];const newPricesForEach = prices.forEach(function (price) {  console.log(price+'원')})const newPricesMap = prices.map(function (price) {  console.log(price+'원')})continue &amp; break👍  forEach, map는 continue,break &gt; Syntax Error 가 발생한다.          try catch 활용      for of, for in 활용      Array.prototype.every, some, find, findIndex …배열 요소를 판별 함수에 전달하고 그 결과의 참/거짓 여부에 따라 반복 여부를 결정      // 에러 발생const orders = ['first','second','third'];orders.forEach(function(order) {  if(order==='second') {    continue;    break;  }  console.log(order);})try {  orders.forEach(function(order) {    if(order==='second') {      continue;      break;    }    console.log(order);  })} catch(e) {}for(const iterator of object) {}for(const key in object) {}",
        "url": "/js-basic-14"
    }
    ,
    
    "js-basic-13": {
        "title": "클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열 고차 함수로 리팩토링)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  배열 다루기 😎유사 배열 객체👍  객체를 배열로 바꿔주는 역할 (Array.from())const arrayLikeObject = {  0: \"HELLO\",  1: \"WORLD\",  length: 2,};// 객체를 배열로 바꿔주는 역할const arr = Array.from(arrayLikeObject);console.log(Array.isArray(arr)); //trueconsole.log(Array.isArray(arrayLikeObject)); //falseconsole.log(arr); // ['HELLO','WORLD']console.log(arr.length); // 2  유사 배열 객체는 forEach,map,reduce, filter 등 고차 함수를 사용할 수 없다.function generatePriceList() {  console.log(Array.isArray(arguments)); //false  // 유사 배열 객체이기 문에 map, forEach, reduce, filter, every, some 기능이 되지 않는다.  for (let index = 0; index &lt; arguments.length; index++) {    const element = arguments[index];    console.log(elements); // 100, 200, 300, 400, 500, 600  }  // return arguments.map((arg) =&gt; arg + \"원\");}generatePriceList(100, 200, 300, 400, 500, 600);  객체를 배열로 바꾸어 사용하면 고차 함수를 사용할 수 있다.function generatePriceList2() {  Array.from(arguments).map((it) =&gt; return arg+'원';}const newList = generatePriceList(100, 200, 300, 400, 500, 600);console.log(newList); // ['100원','200원' .....]불변성👍  배열을 복사한다.  새로운 배열을 반환하는 메서드들을 활용한다. (filter, map, slice)const originArray = [\"123\", \"456\", \"789\"];const newArray = originArray;originArray.push(10);originArray.push(11);originArray.push(12);originArray.unshift(0);console.log(originArray); //  [0,'123','456','789',10,11,12]console.log(newArray); //  [0,'123','456','789',10,11,12]  배열을 복사할 경우, 객체 구조 분해 할당을 사용해본다.const originArray = [\"123\", \"456\", \"789\"];const newArray = [...originArray];originArray.push(10);originArray.push(11);originArray.push(12);originArray.unshift(0);console.log(originArray); //  [0,'123','456','789',10,11,12]console.log(newArray); //  ['123','456','789']for문 배열 고차 함수로 리팩토링👍const price = [\"2000\", \"3000\", \"4000\", \"1000\", \"5000\"];function getWonPrice(priceList) {  let temp = [];  for (let i = 0; i &lt; priceList.length; i++) {    temp.push(priceList[i] + \"원\");  }  return temp;}const result = getWonPrice(price);function getWonPrice2(priceList) {  return priceList.map((price)) =&gt; {    it+'원'  })}const result = getWonPrice2(price);  요구사항🖐 : 1000원이상 추가로 필터const price = [\"2000\", \"3000\", \"4000\", \"1000\", \"5000\"];const suffixWon = (price) =&gt; price + \"원\";const isOverOneThousand = (price) =&gt; Number(price) &gt; 1000;function getWonPrice(priceList) {  const isOverList = priceList.filter(isOverOneThousand);  return isOverList.map(suffixWon);}const result = getWonPrice(price);  요구사항🖐 : 정렬const price = [\"2000\", \"3000\", \"4000\", \"1000\", \"5000\"];const suffixWon = (price) =&gt; price + \"원\";const isOverOneThousand = (price) =&gt; Number(price) &gt; 1000;const ascendingList = (a, b) =&gt; a - b;function getWonPrice(priceList) {  const isOverList = priceList.filter(isOverOneThousand);  const sortList = isOverList.sort(ascendingList);  return isOverList.map(suffixWon);}const result = getWonPrice(price);하지만 계속 요구사항이 많아진다면 어떻게 해결할까?다음 챕터에..",
        "url": "/js-basic-13"
    }
    ,
    
    "js-basic-12": {
        "title": "클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length, 배열 요소에 접근하기)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  배열 다루기 😎JS의 배열은 객체다👍const arr = [1, 2, 3];arr[3] = \"test\";arr[\"property\"] = \"string value\";arr[\"obj\"] = {};arr[{}] = [1, 2, 3];arr[\"func\"] = function () {  return \"hello\";};for (let i = 0; i &lt; arr.length; i++) {  console.log(arr[i]);}// 1 2 3 출력console.log(arr);// 1 2 3 test property:'string value' obj:{} '[object Object]':[1,2,3] func: ... 출력const obj = {  arr: [1, 2, 3],  3: \"test\",  property: \"string value\",  obj: {},  \"{}\": [1, 2, 3],  func: function () {    return \"hello\";  },};for (let i = 0; i &lt; arr.length; i++) {  console.log(arr[i]);}// 1 2 3 출력console.log(arr);// 1 2 3 test property:'string value' obj:{} '{}':[1,2,3] func: ... 출력arr = [1, 2, 3];arr = {  0: 1,  1: 2,  2: 3,};const arr = \"[1,2,3]\";console.log(Array.isArray(arr)); // falseconst arr = [1, 2, 3];console.log(Array.isArray(arr)); // trueArray.length👍  배열의 길이보다는 배열의 마지막 순서 번호에 가깝다.const arr = [1, 2, 3];console.log(arr.length); // [1,2,3] 3arr.length = 10;console.log(arr.length); // [1,2,3,,,,,,] =&gt; 10const arr = [1, 2, 3];arr[3] = 4;console.log(arr.length); // 4arr[9] = 10;console.log(arr.length); // [1,2,3,,,,,10] 10Array.prototype.clear = function () {  this.length=0;}function clearArray(array) {  array.length = 0;  return array;}const arr = [1,2,3]arr.clear()const.log(arr) // []const arr2 = [1,2,3]console.log(clearArray(arr2)) // []배열 요소에 접근하기👍  단순히 0,1로 접근하는게 아닌 명시적 표현을 사용한다.function operateTime(input, operators, is) {  inputs[0].split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  };  inputs[1].split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  });}// React useState와 유사function operateTime2(input, operators, is) {  const [firstInput, secondInput] = inputs  firstInput.split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  });  secondInput.split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  });}// 명시적 표현(변수) 생성function operateTime3(firstInput, secondInput, operators, is) {  const [firstInput, secondInput] = inputs  firstInput.split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  });  secondInput.split('').forEach((num) =&gt; {    cy.get.('.digit').contains(num).click();  });}operateTime3([1,2],1,2);const confirmbtn = document.getElementsByTagName(\"button\")[0];const cancelbtn = document.getElementsByTagName(\"button\")[1];const resetbtn = document.getElementsByTagName(\"button\")[2];const [confirmbtn, cancelbtn, resetbtn] =  document.getElementsByTagName(\"button\");functon formatDate1(targetDate) {  const date = targetDate.toISOString().split('T')[0];  const [year, month, day] = date.split('-');  return `${year}년 ${month}월 ${day}일`;}functon formatDate2(targetDate) {  const [date] = targetDate.toISOString().split('T');  const [year, month, day] = date.split('-');  return `${year}년 ${month}월 ${day}일`;}// 배열 맨 앞을 나타내는 함수 생성 ?(명시적 표현)function head(arr) {  return arr[0] ?? ''}functon formatDate3(targetDate) {  const [date] = head(targetDate.toISOString().split('T'));  const [year, month, day] = date.split('-');  return `${year}년 ${month}월 ${day}일`;}",
        "url": "/js-basic-12"
    }
    ,
    
    "js-basic-11": {
        "title": "클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish coalescing operator, 드모르간 법칙)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  분기 다루기 😎Default case 고려하기👍  기본값을 정해놓는다.function sum(x, y) {  x = x || 1;  y = y || 1;  return x + y;}sum();function createElement(type, height, width) {  const element = document.createElement(type || \"div\");  element.style.height = height || 100;  element.style.width = width || 100;  return element;}createElement();function registerDay(userInputDay) {  switch (userInputDay) {    case \"월요일\":    case \"화요일\":    case \"수요일\":    case \"목요일\":    case \"금요일\":    case \"토요일\":    case \"일요일\":    default:      throw Error(\"입력값이 유효하지 않습니다.\");  }}registerDay(\"월ㄹ요일\");parseInt(x, base);// 안전하게 default 값을 넣어준다.function safeParseInt(number, radix) {  return parseInt(number, radix || 10);}safeParseInt(x);Nullish coalescing operator👍function createElement(type, height, width) {  const element = document.createElement(type || \"div\");  element.style.height = height || 100;  element.style.width = width || 100;  return element;}const el = createElement(\"div\", 0, 0);el.style.height; // 100px &gt; 0은 falsy이므로 100 default 값el.style.width; // 100px &gt; 0은 falsy이므로 100 default 값// null or undefined =&gt; ??// falsy =&gt; ||function createElement2(type, height, width) {  const element = document.createElement(type || \"div\");  element.style.height = height ?? 100;  element.style.width = width ?? 100;  return element;}const el2 = createElement(\"div\", 0, 0);el2.style.height; // 0pxel2.style.width; // 0pxfunction helloWorld(message) {  if (!message) {    return \"Hello! World!\";  }  return \"Hello \" + (message || \"World\");}// 에러 발생console.log(helloWorld(0)); // Hello! World!// 에러가 발생한다.null || undefined ?? \"foo\" // JS가 오류를 방지하기 위해 만듬 Syntax error(null || undefined) ?? \"foo\" // 이렇게 우선순위를 두어서 사용해야한다.드모르간 법칙👍무엇이 더 명시적인가?  조건문 중 연산이 더 붙을 경우 드모르간 법칙을 사용할 수 있다.  true === not false  false === not trueconst isValidUser = true; // 서버에서 가져온 데이터const isValidToken = true; // 서버에서 가져온 데이터if (isValidUser &amp;&amp; isValidUser) {  console.log(\"로그인 성공!\");}if (!isValidUser || !isValidUser) {  console.log(\"로그인 실패!\");}if (A &amp;&amp; B) {  // 성공}if (!A || !B) {  // 성공}",
        "url": "/js-basic-11"
    }
    ,
    
    "js-basic-10": {
        "title": "클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early Return)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  분기 다루기 😎else if &amp; else 피하기👍  Promise then chaining 과 같은 오해  많이 늘어질 경우에는 switch 문을 사용하는 것이 좋다.const x = 1;if (x &gt;= 0) {  console.log(\"x는 0과 같거나 크다\");} else if (x &gt; 0) {  console.log(\"x는 0보다 크다\");}// 위와 똑같은 예if (x &gt;= 0) {  console.log(\"x는 0과 같거나 크다\");} else {  if (x &gt; 0) {    console.log(\"x는 0보다 크다\");  }}const getActiveUserName = (user) {  if(user.name) {    return user.name;  }}// 함수가 2가지 역할을 할 때 에러가 난다.// =&gt; 참,거짓으로 반대되는 결과를 가져오는 elsefunction getHelloCustomer(user) {  if(user.age &lt; 20) {    report(user);  }  // else { =&gt; else 사용시 return '인냥하세요' 실행이 되지 않는다.  return '안녕하세요';  // }}Early Return👍// 읽기 어려움function loginService(isLogin, user) {  if (!isLogin) {    if (checkToken()) {      if (!user.nickName) {        return registerUser(user);      } else {        refreshToken();        return \"로그인 성공\";      }    } else {      throw new Error(\"No Token\");    }  }}function loginService2(isLogin, user) {  // Early Return  /**   * 함수를 미리 종료   * 사고하기 편하다.   */  if (isLogin) {    return;  }  if (!checkToken) {    throw new Error(\"No Token\");  }  if (!user.nickName) {    return registerUser(user);  }  refreshToken();  return \"로그인 성공\";}function 오늘하루(condition, weather, isJob) {  if (condition === \"GOOD\") {    공부();    게임();    유투브보기();  }  if (weather === \"GOOD\") {    운동();    빨래();  }  if (isJob) === \"GOOD\") {    야간업무();    조기취침();    유투브보기();  }}function 오늘하루(condition, weather, isJob) {  if (condition !== \"GOOD\") {    return  }  공부();  게임();  유투브보기();  if (weather !== \"GOOD\") {    return  }  운동();  빨래();  if (isJob !== \"GOOD\") {    return  }  야간업무();  조기취침();  유투브보기();}부정 조건문 지양하기👍  생각을 여러번 해야할 수 있다.  프로그래밍 언어 자체로 if문이 처음부터 오고 true부터 실행시킨다.부정 조건 사용하는 예외  Early Return  Form Validation  보안 혹은 검사하는 로직const isCondition = true;const isNotCondition = false;// NaN// Not a Numberif(!isCondition) {  console.log(\"거짓인 경우에만 실행\")}if(isNotCondition) {  console.log(\"거짓인 경우에만 실행\")}function isNumber(num) {  return !Number.isNaN(num) &amp;&amp; typeof num ==='number';}is(isNumber(3)) {  console.log('숫자입니다.')}",
        "url": "/js-basic-10"
    }
    ,
    
    "js-basic-9": {
        "title": "클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  분기 다루기 😎truthy &amp; falsy👍if (\"string\".length) {}if (10) {}if (boolean) {}// truthytrue;{}[];42;(\"0\");(\"false\");new Date();3.14 - 3.14;Infinity - Infinity;// falsyfalse;null;undefined;0;0n;NaN;(\"\");단락 회로 평가👍true &amp;&amp; true &amp;&amp; \"도달O\";true &amp;&amp; false &amp;&amp; \"도달X\";false || false || \"도달O\";false || true || \"도달X\";function fetchDate() {  if (state.data) {    return state.data;  } else {    return \"Fetching....\";  }}return state.data ? state.data : \"Fetching...\"; // 삼항 연산자 이용return state.data || \"Fetching...\"; // 단락회로 평가 이용// 안 좋은 예function favoriteDog(someDog) {  let favoriteDog;  if(someDog) {    favoditeDog = someDog;  } else {    favoriteDog='냐옹'  }  return favoriteDog;})// 좋은 예function favoriteDog(someDog) {  return someDog||'냐옹';}favoriteDog() // =&gt; 냐옹favoriteDog('뽀삐') // =&gt; 뽀삐// 안 좋은 예const getActiveUserName = (user, isLogin) {  if(isLogin) {    if(user){      is(user.name){        return user.name;      } else {        return '이름없음';      }    }  }}// 좋은 예const getActiveUserName = (user, isLogin) {  if(isLogin &amp;&amp; user) {    if(user.name) {      return user.name;    } else {      return '이름없음';    }  }}// 더 좋은 예const getActiveUserName = (user, isLogin) {  if(isLogin &amp;&amp; user) {    return user.name || '이름없음  }",
        "url": "/js-basic-9"
    }
    ,
    
    "js-basic-8": {
        "title": "클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  분기 다루기 😎값식문👍고차함수 활용 (map,filter,reduce)  식이 들어올 자리에 값이 들어올 수 있는가?  값이 들어올 자리에 식이 들어올 수 있는가?  JSX// 틀린 예&lt;div id={if (condition) {'msg'}}&gt;Hello World!&lt;/div&gt;// transfiling// Is transformed to this JS// 틀린 예ReactDOM.render(React.createElement('div',{id: if(contion) {'msg'}}, 'Hello World!'));const obj = {id : if(condition) {'msg'}}// 옳은 예ReactDOM.render(&lt;div id={condition? 'msg' : null}&gt; Hello World!&lt;/div&gt;,moundMode);// 틀린 예{  () =&gt; {    const rows = [];    for (let i = 0; i &lt; objectRows.length; i++) {      rows.push(&lt;ObjectRow key={i} data={objectRows[i]} /&gt;);      return rows;    }  };}// 옳은 예{  objectRows.map((obj, i) =&gt; {    &lt;ObjectRow key={i} data={obj} /&gt;;  });}// 틀린 예{  () =&gt; {    if (contidionOne) return &lt;span&gt;One&lt;/span&gt;;    if (contidionTwo) return &lt;span&gt;Two&lt;/span&gt;;    else conditionOne;    return &lt;span&gt;Three&lt;/span&gt;;  };}// 옳은 예{  conditionOne &amp;&amp; &lt;span&gt;One&lt;/span&gt;;}{  contidionTwo &amp;&amp; &lt;span&gt;Two&lt;/span&gt;;}{  !contidionTwo &amp;&amp; &lt;span&gt;Three&lt;/span&gt;;}삼항 연산자👍// 코드를 해석하기 어렵다.function example() {  return condition1    ? value1    : condition2    ? value2    : condition3    ? value3    : value4;}// if else 반복function example2() {  if (condition1) {    return value1;  } else if (condition2) {    return value2;  } else if (condition3) {    return value3;  } else {    return value4;  }}// Switch 문 이용하는 것이 유용하다.function example3() {  switch (key) {    case condition1:      break;    case condition2:      break;    case condition3:      break;    default:      break;  }}const example = condition ? (a === 0 ? \"zero\" : \"positive\") : \"negative\";const welcomeMessage = (isLogin) =&gt; {  const name = isLogin ? getName() : \"이름없음\";  return name;};const welcomeMessage = (isLogin) =&gt; {  if (isLogin) {    return getName();  }  return \"이름없음\";};  삼항연산자를 이용해 값을 만들어 변수로 만들 때 사용  함수가 내뱉는 값을 반환하는 간단한 식일 때(return) 사용function alertMessage(isAdult) {  isAdult  ? alert(\"입장이 가능합니다.\")  : alert(\"입장이 불가능합니다.\")}function alertMessage(isAdult) {  if(isAdult) {    alert(\"입장이 가능합니다.\")  } else {  : alert(\"입장이 불가능합니다.\")  }}Solution🌼삼항 연산자 사용할 때  좌항 우항을 따졌을 때  3개 피연산자를 사용할 때  조건? 참:거짓",
        "url": "/js-basic-8"
    }
    ,
    
    "js-basic-7": {
        "title": "클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  경계 다루기 😎min-max👍  최소값과 최대값을 다룬다.  포함 여부를 결정해야 한다(이상-초과 / 이하-미만)  혹은 네이밍에 최소값 최대값 포함 여부를 작성한다.function genRandomNumber(min, max) {return Math.floor(Math.random() * (max - min + 1)) + min;}const MIN_NUMBER = 1;const MAX_NUMBER = 45;// MAX_NUMBER_LIMIT 초과// MAX_IN_NUMBER 포함const result = genRandomNumber(MIN_NUMBER, MAX_NUMBER);console.log(result);const MAX_AGE = 20;function isAdult(age) {// 최소값, 최대값 (포함되는지 vs 안되는지)// 이상, 초과 vs 이하, 미만if(age&gt;=20) {return;}Begin-End👍  경계를 포함하지만 제외하는 경우  달력, 에어비엔비와 같은 출국,입국일을 생각하면 쉽다.function reservationDate(beginDate, endDate) {  // ....some code  return;}reservationDate(\"YYYY-MM-DD\", \"YYYY-MM-DD\");First-Last👍  포함된 양 끝을 의미한다.  포함되어 있는 규칙이나 연속성에 대해 보장 X  부터 ~~~ 까지const students = [\"A\", \"B\", \"C\"];function getStudents(first, last) {  // ...some code}getStudents(students[0], students[2]);Prefix(접두사) - Suffix(접미사)의 중요성 (규칙) 👍  JS의 prefix getter, setter  React usePrefix (기본 Hooks, useState,useEffect …)  jQuery prefix $매개변수 순서가 경계 👍호출하는 함수의 네이밍과 인자의 순서의 연관성을 고려한다.  매개변수를 2개가 넘지 않도록 만든다.  arguments, rest parameter 사용  랩핑하는 함수 사용  매개변수를 객체로 담아서 넘긴다function someFunc(someArg1, someArg2, someArg1, someArg2) {}function getFunc(someArg3, someArg4) {  // 많이 쓰는 매개변수 일 경우 이렇게 들고온다.  someFunc(undefined, undefined, someArg3, someArg4);}function someFunc2({ someArg1, someArg2, someArg1, someArg2 }) {}getRandomNumber(1, 50);getDates(\"2021-01-01\", \"2021-12-31\");shuffleArray(1, 5);",
        "url": "/js-basic-7"
    }
    ,
    
    "js-basic-6": {
        "title": "클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  타입 다루기 😎형변환 주의하기👍http://dorey.github.io/JavaScript-Equality-Table/  느슨한 검사 =&gt; 암묵적 형 변환console.log(\"1\" == 1);console.log(1 == true);console.log(0 == false);console.log(11 + \" 문자와 결합\"); // '11 문자와 결합'console.log(!!\"문자열\"); // trueconsole.log(!!\"\"); // falseparseInt(\"9.999\", 10); // 9 (10진수)// 명시적 변환 (옳은 예)console.log(String(11 + \" 문자와 결합\")); // '11 문자와 결합'console.log(Boolean(!!\"문자열\")); // trueconsole.log(Boolean(!!\"\")); // false사용자가 형변환시 명시적 변환자바스크립트 엔진이 평가시 암묵적 형변환▻ 타입 변환시 명시적 변환을 해주어야 한다.isNaN👍console.log(Number.MAX_SAFE_INTEGER); //9007199254740991console.log(Number.isInteger); //ƒ isInteger() {}is Not A Number =&gt; 숫자가 아니다.isNaN(123) // false =&gt; 숫자가 맞다.typeof 123 === 'number' // trueisNaN(123+'테스트') // true =&gt; 숫자가 아니다.Number.isNaN(123+ '테스트') // false =&gt; 숫자가 맞다.ES2015+ 이후 버전  isNaN ▻ 느슨한 검사  Number.isNaN ▻ 엄격한 검사",
        "url": "/js-basic-6"
    }
    ,
    
    "js-basic-5": {
        "title": "클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  타입 다루기 😎undefined &amp; null 👍console.log(null); // nullconsole.log(!null); // trueconsole.log(!!null); // falseconsole.log(null === false); // false// null =&gt; math =&gt; 0console.log(null + 123); // 123// 선언했지만 정의되지 않고 할당 Xlet varb;console.log(varb); //undefinedconsole.log(typeof varb); // undefinedconsole.log(varb + 10); // NaNconsole.log(!undefined); // trueconsole.log(undefined == null); // trueconsole.log(undefined === null); // falseconsole.log(!undefined === !null); // true차이점      undefined, null =&gt; 값이 없거나(명시적 표현) 정의되지 않음    undefined ▻ NaN ▻ type undefined  null ▻ 0 ▻ type Objecteqeq 줄이기 (동등 연산자 ==)👍equality (==)  형변환(type casting)이 일어난다.console.log(1 === 1); // trueconsole.log(1 === \"1\"); // true//Strict equality(===)console.log(1 === 1); // trueconsole.log(1 === \"1\"); // falseconst ticketNum = document.querySelector(\"#ticketNum\");console.log(ticketNum.value); // '0'console.log(ticketNum.value &gt; 1000); // falseconsole.log(ticketNum.value === 0); // falseconsole.log(ticketNum.value == 0); // 위험 협업시 알아듣기 어렵다.// 옳은 예console.log(Number(ticketNum.value) === 0); // trueconsole.log(ticketNum.valueAsNumber == 0); // true",
        "url": "/js-basic-5"
    }
    ,
    
    "js-basic-4": {
        "title": "클린코드 자바스크립트 2-1 타입 다루기(타입 검사)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  타입 다루기 😎타입 검사👍  PRIMITIVE vs REFERENCE  Recference 는 객체 (Array, function, Date …)  typeof 로 감별해내기 어렵다.function myFunction() {}class MyClass {}const str = new String(\"문자열\");typeof \"문자열\"; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof 123; // 'number'typeof Symbol(); // 'symbol'typeof myFunction; // 'function'typeof MyClass; // 'functiontypeof str; // 'undefined'가장 치명적인 문제 😥자바 스크립트가 인정한 오류typeof null; // 'object'  자바스크립트는 동적으로 변하는 언어 ▻ 타입 동적  객체의 프로토타입 체인을 확인하는 법 (객체 확인에 용이)function Person(name, age) {  this.name = name;  this.age = age;}const p = {  name: \"test\",  age: 85,};const poco = new Person(\"poco\", 99);poco instanceof Person; // truep instanceof Person; // falseconst arr = [];const func = function () {};const date = new Date();arr instanceof Array; // truefunc instanceof Function; // truedate instanceof Date; // true// 최상위에 Object 가 있으므로 truearr instanceof Object; // truefunc instanceof Object; // truedate instanceof Object; // trueObject.prototype.toString.call(arr); // '[object Array]'Object.prototype.toString.call(func); // '[object Function]'Object.prototype.toString.call(date); // '[object Date]'  자바스크립트는 동적인 타입을 가진 언어이다.  타입 검사가 어려움 하나하나 잘 찾아가면서 검사 해야한다.  어떠한 부분이 주의해야할지 외우는게 아닌 하나하나 잘 찾아서 검사해야한다!  Primitive vs Reference / typeof instanceof 등Solution 🌼아래와 같은 내용으로 Stack Overflow , Google 최신 검색해보며 타입 검사  javascript is function  javascript is Array  javascript is String}",
        "url": "/js-basic-4"
    }
    ,
    
    "js-basic-3": {
        "title": "클린코드 자바스크립트 1-3 변수 다루기(호이스팅)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  변수 다루기 😎호이스팅 👍  런타임시 선언과 할당이 분리되는 것  런타임시 선언이 최상단으로 끌어올려진다.  var 경우, 할당이 제대로 되지 않았을 때, 선언했다면 undefinedvar global = 0;function outer() {  console.log(global); // undefined  var global = 5;  function inner() {    var global = 10;    console.log(global); // 10  }}inner();global = 1;console.log(global); // 1outer();function duplicatedVar() {  var a;  console.log(a); // undefined  var a = 100;  console.log(a); // 100}console.log(duplicatedVar()); // undefinedvar sum;console.log(typeof sum); // functonconsole.log(sum); // 3function sum() {  return 1 + 2;}  const를 사용해 함수를 만들고 할당하는 방식(함수 표현식)을 추천console.log(sum()); //errorconst sum = () =&gt; {  return 1 + 2;};호이스팅 문제 😫  코드 작성시 예측과 실행이 다른 문제가 생긴다.  var 사용 X &gt; let,const 지향  함수 조심 &gt; 함수 표현식 사용",
        "url": "/js-basic-3"
    }
    ,
    
    "js-basic-2": {
        "title": "클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  변수 다루기 😎전역 공간 사용 최소화 👍누구에게 들어보았나요?  경험  누군가 혹은 자바스크립트 생태계  강의 혹은 책  회사 혹은 책  Lint전역 (최상위)  Window (Web Browser)  global (NodeJS)ex) index.js 와 index2.js를 웹이 같이 불러올 때,  아래와 같이, setTimeout 에러 없이 동작 불가  Web API이기 때문에 에러가 나오지 않는다.// index.js)var globalVar = 'global';console.log(globalVar);console.log(window.globalVar);var setTimeout = 'setTimeout';// 에러 없이 동작 불가,// Web API이기 때문에 에러가 나오지 않는다.function setTimeout() {    console.log('function)}// index2.js)console.log(globalVar) // 사용 가능setTimeout(() =&gt;{console.log('1초')};,1000);  index 라는 전역 변수가 남는다.  let 이나 const 로 바꾸어주어야함for (var index = 0; index &lt; array.length; index++) {  const element = array[index];}//전역 공간을 더럽히면 왜 안될까?🤦‍♂️  어디서나 접근 가능하다.  스코프 분리 위험(사람이 생각하기에 분리했지만 런타임 환경에서는 분리하지 못했다.)전역 공간을 더럽히지 않는 방법 🌻  전역 변수 X  지역 변수 O  window, global을 조작 X  const, let OK  IIFE, Module, Closure , Scope 분리임시 변수 제거하기  임시 변수 혹은 객체를 어떻게 제거해야 메모리 공간을 차지하지 않는다.const $ = (value) =&gt; {    document.querySelector(value);}// 안 좋은 예 function getElements1() {     임시 객체 CRUD     const result = {        title : $('.title'),        text : $('.text'),        value : $('.value'),    };    return result; }// 좋은 예 function getElements2() {    return {        title : $('.title'),        text : $('.text'),        value : $('.value'),    }; }  추가적인 스펙을 요구할 때 (날짜에 대한 요구 사항)  내가 할 수 있는 것은 2가지 방식이 있다.  함수 추가  함수 수정 (문제가 생길 수 있다.)  함수 수정 예시// 잘못된 예function getDateTime(targetDate) {  let month = targetDate.getMonth();  let day = targetDate.getDay();  let hour = targetDate.getHour();  month = month &gt;= 10 ? month : \"0\" + month;  day = day &gt;= 10 ? month : \"0\" + day;  hour = hour &gt;= 10 ? hour : \"0\" + hour;  return {    month,    day,    hour,  };}  함수 추가 예시          임시 변수의 유혹을 벗어나야 한다. (추상화 과정을 거친다.)      함수는 하나의 역할만 하도록 한다.      // 좋은 예function getDateTime(targetDate) {    const month = targetDate.getMonth();    const day = targetDate.getDay();    const hour = targetDate.getHour();    return {    month : month &gt;= 10? month : '0' + month;    day  : day &gt;= 10? month : '0' + day;    hour : hour &gt;= 10? hour : '0' + hour;    }function getDateTime1() {    const currentDateTime = getDateTime(new Date());    return {    month : computedKrDate(currentDateTime.month) +'분 전'    day  : computedKrDate(currentDateTime.day) +'분 전'    hour : computedKrDate(currentDateTime.hour) +'분 전'    }}function genRandomNumber(min, max) {  const randomNumber = Math.floor(Math.random() * (max + 1) + min);  return randomNumber;}임시 변수를 제거해야 하는 이유?  명령형으로 가득한 Logic이 나온다.  어디서 어떻게 잘못되었는지 디버깅이 어렵다.  추가적인 코드를 작성하고 싶은 유혹에 빠진다. (함수는 하나의 기능)Solution 🌼  함수 나누기  고차 함수(map,filter,reduce)  바로 반환  선언형 프로그래밍",
        "url": "/js-basic-2"
    }
    ,
    
    "js-basic": {
        "title": "클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)",
            "author": "John",
            "category": "",
            "content": "  Clean Code JS 강좌는 여러 절로 구성되어 있습니다.      클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp;      block scope)          클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수      제거하기)        클린코드 자바스크립트 1-3 변수 다루기(호이스팅)        클린코드 자바스크립트 2-1 타입 다루기(타입 검사)        클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)        클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)        클린코드 자바스크립트 3-1 경계      다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가      경계)        클린코드 자바스크립트 4-1 분기 다루기(값식문, 삼항 연산자)        클린코드 자바스크립트 4-2 분기 다루기(truthy &amp; falsy, 단락 회로 평가)        클린코드 자바스크립트 4-3 분기 다루기(else if &amp; else 피하기, Early      Return, Default case 고려하기)        클린코드 자바스크립트 4-4 분기 다루기(Default case 고려하기, Nullish      coalescing operator, 드모르간 법칙)        클린코드 자바스크립트 5-1 배열 다루기(JS의 배열은 객체다, Array.length,      배열 요소에 접근하기)        클린코드 자바스크립트 5-2 배열 다루기(유사 배열 객체, 불변성, for문 배열      고차 함수로 리팩토링)        클린코드 자바스크립트 5-3 배열 다루기(배열 메소드 체이닝 활용, map vs      forEach, continue&amp;break)        클린코드 자바스크립트 6-1 객체 다루기(Object Destructuring,      Object.freeze)        클린코드 자바스크립트 6-2 객체 다루기(Prototype 조작 지양하기,      hasOwnProperty, 직접 접근 지양하기)        클린코드 자바스크립트 7-1 함수 다루기([함수,메서드,생성자], argument &amp;      parameter,복잡한 인자 관리하기)        클린코드 자바스크립트 7-2 함수 다루기(default value, Rest Parameters,      void &amp; return, 화살표 함수)        클린코드 자바스크립트 7-3 함수 다루기(Callback Function, 순수 함수,      Closure)  변수 다루기 😎var를 지양하자. 👍  let &amp; const 사용var : 함수 스코프let &amp; const : 블록 단위 스코프 + Temporary Dead Zone  var는 변수 선언 및 할당 재사용 가능var name = \"이름\";console.log(name);var name = \"이름2\";console.log(name);  호이스팅으로 인해, 변수 선언이 먼저 가기 때문에 아래와 같이 undefined가 나온다.console.log(name2); // undefinedvar name2 = \"hello\";console.log(name2);  let (변수 선언 및 재할당 가능)let name = \"이름\";name = \"이름2\";  const (변수 선언시 할당해주어야 한다)const name = \"이름;function scope &amp; block scope 👍  var는 Function 단위이므로 지역에서 할당한 변수가 전역까지 오염된다.var global = \"전역\"if (global ===\"전역) {    var global = '지역'    console.log(global); // 지역}console.log(global) // 지역  let는 block 단위이므로 전역에 오염되지 않는다.let global = \"전역\"if (global ===\"전역) {    var global = '지역'    console.log(global); // 지역}console.log(global) // 전역  let보다 const를 사용하는 것이 좋다.  const는 재할당 불가만 기억하면 된다.객체 조작은 문제 없음const person = {    name : \"john\",    age : 27,}// Error 발생(재할당 불가)// person = {//   name : \"john2\",//    age : 30,person.name = \"john2\";person.age = 30;}배열 조작시에도 문제 없음const numList = [1, 2, 3, 4, 5];numList.push(1);",
        "url": "/js-basic"
    }
    ,
    
    "cnn-basic-6": {
        "title": "합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  ResNet  ILSVRC 2015 우승 (3.6% Top 5 Error)한 모델이며 Deep Residual Learning 이라고도 부른다.  152개의 Layer 구조이며 8배 깊은 Layers를 가졌음에도 불구하고 실행 시간이 VGGNet보다 빠르다.  이 모델은 일반적인 레이어만 깊은 모델들과 비교했을 때 성능이 좋을 뿐만 아니라 학습 속도도 더 빠르다.Introduction  VGGNet 논문에서 CNN 의 레이어가 깊어질수록 성능이 더 좋다는 것을 확인할 수 있었다.  하지만 레이어가 너무 깊어지면 Vanishing/Exploding gradient, 그리고 degradation problem 크게 이 두 가지 문제점에 봉착한다.  우선 Vanishing/Exploding gradient 같은 경우에는 레이어 사이에 batchNorm 을 적용해주면 해결할 수 있다.Degradation Problem 이란 정확도가 어느 순간부터 정체되고 레이어가 더 깊어질수록 성능이 더 나빠지는 현상을 의미한다.이 논문에서는 Residual Learning 을 통해 Degradation Problem 을 해결하는 방법을 제시한다.  간단하게 input 을 x, input이 통과하는 Function 을 F(x), 그리고 Output 을 H(x) 이라고 가정해보자. F(x) = H(x) - x 를 최소화시키는 Residual mapping으로 H(x)를 재정의한다.   Residual Learning 에서는 F(x) 를 H(x) - x 라고 define 해 주었다. 원래 Output H(x) 에서 자기 자신인 x 를 빼주기 때문에 ‘Residual Learning’ 이라는 이름을 가지게 된다.   또 x 가 이 F(x) 를 통과한 이후에, 이 값은 자기 자신인 x 와 더해주고, Layer를 Skip해서 더해주기에 ‘Skip Connections’ 이라고 부른다. 이 Residual Block 을 통과하고 나면 최종적인 값은 F(x) + x 가 나오게 된다.  F(x) 와 x 를 직접적으로 더해주기 위해선 F(x) 와 x 가 서로 같은 Dimension 이어야 한다. 일반적으로 F(x) 와 이전의 input x가 채널수가 같다면 별다른 조치를 취해주지 않아도 그냥 더해주면 된다.  하지만 Channel 개수가 달라지거나 MaxPool 등에 의해서 x 의 크기가 달라질 때, padding 이나 별다른 Ws 를 곱해주어서 사이즈를 매칭 시켜주는 것이 중요하다.ResNet Architecture  ResNet 의 기본 구조는 VGGNet-34 을 따른다. 위 그림을 보면 VGG-34 과 모델 구성은 같은데, 레이어 두개마다 Skip Connection 을 해준다는 것을 볼 수 있다.  중간에 점선으로 표시된 Skip Connection 은 x 와 F(x) 의 Dimension 이 달라져서 따로 맞춰줘야 되는 Skip Connection 들을 의미한다.Deeper Bottleneck Architectures  네트워크의 깊이가 50 을 넘어가면, 제아무리 ResNet을 이용하고 3x3 필터만 사용한다 할지라도 Training 시간이 매우 길어질 수 있다. 따라서 이 경우엔 원래 모델 구조에서 약간의 수정이 필요하다.  3x3 필터를 두 번 사용하는 대신, 1x1 -&gt; 3x3 -&gt; 1x1 필터들을 사용하는 구조를 만든다. 이렇게 수정한 구조는 Dimension 의 크기를 줄일 뿐만 아니라 시간 복잡도도 줄이는 효과를 볼 수 있다.ExperimentsResNet 은 1000개의 클라스로 이루어진 ImageNet 2012 데이터셋으로 training  위 그래프에서 왼쪽 그림은 Plain Network 의 18, 34 Layer, 오른쪽 그림은 ResNet 의 18, 34 layer 의 Loss 과정이다.  우선 왼쪽 그림에서는 Degradation Problem 이 보이는 것을 확인할 수 있다. 34-Layer 네트워크가 18-layer 보다 Loss 가 높기 때문이다.  반면 ResNet 같은 경우엔 34-Layer 가 Loss 가 더 낮게 나오는 것을 확인할 수 있다. Degradation Problem 이 해결됐음을 보여주는 그래프이다.  위 표에서는 더 깊은 ResNet 들의 성능을 보여준다. 레이어가 깊어지면 깊어질수록 error 는 줄어드는 경향성을 볼 수 있고, 110 개의 레이어가 있을 때 가장 적은 에러가 나온다.  하지만 그렇다고 너무 깊어지면, 예를 들어 1000 개 이상의 레이어가 존재할 때는 오버피팅으로 인하여 성능이 더 얕은 모델들보다 더 안 좋게 나온다.참조 문헌[1] He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition (pp. 770-778).https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf",
        "url": "/cnn-basic-6"
    }
    ,
    
    "cnn-basic-5": {
        "title": "합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  VGGNet  ILSVRC 2014 대회에서 2등을 차지한 Karen Simonyan과 Andrew Zisserman이 만든 CNN 모델  ILSVRC는 ImageNet Large Scale Visual Recognition Challenge의 약자로, 2010년에 시작된 이미지 인식(Image Recognition) 경진대회VGG-16 Architecture  13 Convolution Layers + 3 Fully-connected Layers  3x3 convolution filters  stride: 1 &amp; padding: 1  2x2 max pooling (stride : 2)  ReLUConfiguration  Input Size RGB 224x224, 복수의 Convolution layer, Max-Pooling층이 반복되는 구조이며 최종단에는 FC layer으로 구성되어 있다.3x3 필터 사용 (Why use smaller filters?)  VGG 모델 이전 Convolutional Network를 활용하여 이미지 분류에서 좋은 성과를 보였던 모델들은 비교적 큰 Receptive Field를 갖는 11x11필터나 7x7 필터를 포함  그러나 VGG 모델은 오직 3x3 크기의 작은 필터만 사용했음에도 이미지 분류 정확도를 비약적으로 개선  파라미터 수를 줄이고 Layer를 다층 쌓아서 모델의 전체 Depth를 깊게 만들기 위해서이다.  Input Size가 7x7이며, 3x3의 Output Size를 도출해내야 한다고 가정하자, 이때 Filter Size가 3x3이라면 총 두 차례의 Convolution을 진행해야 한다.  반면 5x5의 Filter Size로는 단 한 번의 Convolution으로 동일한 사이즈의 Feature Map을 산출한다. 3x3 Filter로 세 차례 Convolution 하는 것은 7x7 Filter로 한 번 Convolution 하는 것과 대응된다.  즉, 3x3 Filter 3개는 7x7 Filter 하나와 동일한 Receptive Field (= Filter가 한 번에 볼 수 있는 입력 이미지의 Spatial Area) 를 가지면서도 더 깊은 레이어를 쌓을 수 있게 하는 것이다.  이처럼 Layer 수가 늘어나면 이미지 특성에 비선형성을 더 추가할 수 있기 때문에(Deeper, more non-linearities), Filter를 통해 추출한 Feature가 점점 유용해지는 이점을 얻게 된다.필터의 크기가 작으면 파라미터 수도 적어진다(Smaller filters, fewer parameters)  3x3 Filter에는 9개의 파라미터가 있다. 이때 Depth를 C라고 한다면 3 x 3 x C 개의 파라미터가 있고, 여기에 출력되는 Feature Map의 개수(=입력 Depth)를 곱하면 각 레이어 당 3x3xCxC의 파라미터를 가지게 된다. 만약 Layer가 3개라면, 총 파라미터는 3 * (32C2)개이다.  반면 7x7 Filter의 경우 7x7xCxC개의 파라미터 수가 있을 것이다. 레이어를 더 적게 쌓았음에도 파라미터 수가 많은 것을 확인할 수 있다.  여기서 파라미터(weight) 수가 적다는 것은 어떤 의미를 가질까? CNN에서 가중치는 모두 훈련이 필요한 것들이므로, 파라미터 수가 적을 수록 학습 속도가 빨라진다는 이점을 얻을 수 있다.결론  VGGNet은 3x3의 작은 필터를 모든 Conv 레이어에 사용하였다.  작은 필터를 사용함으로써 더 많은 ReLU함수를 사용할 수 있고 더 많은 비선형성을 확보할 수 있었다.  VGGNet의 A~E까지 각각의 다른 모델이 아니라 학습의 단계부터 알 수 있듯, 업그레이드된 모델이다.  위와 같은 특징들로 AlexNet보다 2배 이상 깊은 네트워크이며 좋은 성능을 가진 모델을 만들어 낼 수 있었다.  줄였음에도 파라미터의 수가 엄청나게 많기 때문에 학습 시간이 오래 걸린다참조 문헌https://arxiv.org/pdf/1409.1556.pdf",
        "url": "/cnn-basic-5"
    }
    ,
    
    "cnn-basic-4": {
        "title": "합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  가중치 초기화가중치가 중요한 이유  Overfitting-Underfitting 문제가 발생해 제대로 학습이 되지 않을 수 있다.  그래디언트 손실(Vanishing Gradient)와 폭주(Exploding)문제가 발생한다.  지역 최적화(Local Optimization)에 실패해 Local mnimum에 수렴하기도 한다.  즉, 같은 모델을 훈련시키더라도 가중치가 어떤 초기 값을 갖느냐에 따라서 모델 훈련 결과가 달라진다.  가중치 값이 0일 경우, 학습이 불가능하다.  가중치 값을 같은 값으로 할 경우, 1개 신경망에 학습시키는 것과 동일  평균 0 ,1보다 작은 표준편차 분포를 사용한다.1) Sigmoid, 정규분포  표준편차가 크기 때문에 학습이 반복될 수록 0,1로 치우치는 문제가 발생2) 1)에서 표준편차를 줄였을 경우  Sigmoid 그래디언트 최댓값이 0.25이므로 현상을 완화할 수는 있지만 0.5로 몰리는 현상“더 나은 방법을 찾아보자”LeCun Initialization  CNN LeNet 창시자 LeCun이 도입  정규분포, Uniform 분포를 따르는 방법 2가지가 있다.Xavier Initialization  이전 노드와 다음 노드 개수에 의존하는 방법  비선형함수(ex. sigmoid, tanh)에서 효과적인 결과He Initialization  Relu 활성화 함수 사용시, Xavier 설정이 비효율적인 결과를 가져온다.(평균, 표준편차 0으로 수렴)  최근 대부분 모델에서 He 초기화를 사용한다.⭐️ 최근 Deep CNN 모델들은 Gaussian Distribution 초기화 방법 사용참조 문헌https://kharshit.github.io/blog/2018/12/28/why-batch-normalizationhttps://reniew.github.io/13/https://wooono.tistory.com/227",
        "url": "/cnn-basic-4"
    }
    ,
    
    "cnn-basic-3": {
        "title": "합성곱 신경망 기초 3(배치정규화, Batch Normalization)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  배치 정규화깊은 신경망일 수록 같은 Input 이라도 가중치가 조금이라도 다르다면 완전히 다른 결과를 가져올 수 있다.“각 층이 활성화를 적당히 퍼뜨리도록 강제로 해보자”  배치란? 신경망 학습시, 전체 데이터를 한 번에 학습시키지 않고, 조그만 단위로 분할해서 학습 시키는 것.  배치 정규화란? 배치 단위로 정규화 하는 것.[배치 정규화 알고리즘]  엡실론은 분모가 0 이 되는 것을 막기 위한 아주 작은 숫자(1e-5~7)  정규화 이후, 배치 데이터들을 scale(감마(γ)), shift(베타(β)) 를 통해 새로운 값으로 바꾼다.  데이터를 계속 정규화 하게 되면, 활성화 함수의 비선형 성질을 잃게 되는 문제 발생      아래 그림과 같이 Sigmoid 함수 경우, 입력 값이 N(0, 1) 이라면, 95% 의 입력 값은 Sigmoid 함수 그래프의 중간 (x = (-1.96, 1.96) 구간)에 속하게 된다.    감마(γ), 베타(β)를 통해 활성함수로 들어가는 값의 범위를 변환하여 비선형 성질을 보존  감마(γ), 베타(β) 값은 학습 가능한 변수, 역전파를 통해서 학습⭐배치 정규화 효과⭐  학습이 빠르게 진행(Epoch 수를 줄이는데 효과적)  Dropout 필요성 감소  더 높은 Learning rate 사용 가능  규제 효과 (과적합 방지)  그래디언트 손실(Vanishing Gradient)와 폭주(Exploding)문제 해결참조 문헌https://kharshit.github.io/blog/2018/12/28/why-batch-normalizationhttps://reniew.github.io/13/https://wooono.tistory.com/227",
        "url": "/cnn-basic-3"
    }
    ,
    
    "cnn-basic-2": {
        "title": "합성곱 신경망 기초 2(CNN, 역전파 Backpropagation)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  CNN foward pass  CNN은 필터가 입력데이터를 슬라이딩하면서 지역적 특징(feature)을 추출  이 특징을 최대값(Max Pooling)이나 평균값(Average Pooling)으로 압축해 다음 레이어로 전달  이런 과정을 반복해 분류 등 원하는 결과를 만들어내는 것이 CNN의 일반적인 구조[Cross-Correlation][Convolution]K(−m,−n) == K(m,n)일 때, Convolution 과 Cross-Correlation이 동일하다.  𝑥𝑖𝑗 는 각각 입력값의 𝑖번째 행, 𝑗번째 열의 요소  3x3 행렬, 2x2 필터(커널), 스트라이드 1  이후 conv 레이어에 최대값이나 평균값을 취해서 정보를 압축(pooling)되어 2x2 행렬이 2x1 벡터로 바뀐다.CNN backward pass[Average Pooling 레이어의 그래디언트 전파 과정]  CNN 역전파 공식 (가중치 변화에 따른 오차 변화량)  HxW feature Map, k1 x k2 kernel 일 때, output은 (H-k1+1),(W-k2+1)  현재 지점(x)의 그래디언트 식  최종 식[Average Pooling]  바로 뒤 레이어로부터 전파된 그래디언트가 𝑑1, 𝑑2  현재 지점의 그래디언트는 미분의 연쇄법칙(chain rule)에 의해 흘러들어온 그래디언트(d)에 로컬 그래디언트(w 혹은 x)를 곱한 것과 같음  Average Pooling을 하는 지점의 로컬 그래디언트는 1/𝑚[Max Pooling]  가장 큰 값이 속해 있는 요소의 로컬 그래디언트는 1, 나머지는 0[Convolution Layer]  𝑥11 은 forward pass 과정에서 2x2필터 가운데 빨간색(𝑤1) 가중치하고만 합성곱이 수행 되므로 역전파 때도 마찬가지로 딱 한번의 역전파가 일어남  Kapathy의 계산그래프 형태로 나타내면 𝑥11 의 그래디언트는 흘러들어온 그래디언트𝑑11에 로컬 그래디언트(𝑤1)를 곱해서 구할 수 있다.  마찬가지로 𝑤1 의 그래디언트는 흘러들어온 그래디언트 𝑑11에 로컬 그래디언트(𝑥11)를 곱해 계산  하지만 이렇게 하나하나 따져가면서 구하려면 식이 복잡하고 이해가 어렵다.  conv layer가 역전파를 할 때 약간의 트릭을 쓰면 조금 더 간단히 그래디언트를 구할 수 있다.간단한 방법  흘러들어온 그래디언트 행렬에(2x2 크기)을 conv layer를 만들 때 썼던 필터가 슬라이딩하면서 값을 구한다  필터 요소의 순서를 정반대로 바꿔 예컨대 빨-파-노-초 필터를 초-노-파-빨 필터로 바꿔서 그래디언트 행렬에 합성곱을 수행해주면 입력벡터(x)에 대한 그래디언트를 구할 수 있다.  필터의 그래디언트는 그래디언트 행렬 첫번째 요소인 𝑑11은 𝑥11, 𝑥12, 𝑥21, 𝑥22와 연결되어 있는 걸 확인할 수 있다. (영향을 끼치는 곳)흘러들어온 그래디언트(𝑑11, 𝑑12, 𝑑21, 𝑑22)에 로컬 그래디언트(x11, x12, x21, x22)를 곱한다.  각각의 로컬 그래다언트는 합성곱 필터 가중치로 연결된 입력값들이기 때문에 𝑑𝑤11은 𝑥11𝑑11+𝑥12𝑑12+𝑥21𝑑21+𝑥22𝑑22참조 문헌https://cs231n.github.io/optimization-2/https://www.jefkine.com/general/2016/09/05/backpropagation-in-convolutional-neural-networks/https://ratsgo.github.io/deep%20learning/2017/04/05/CNNbackprop/",
        "url": "/cnn-basic-2"
    }
    ,
    
    "cnn-basic": {
        "title": "합성곱 신경망 기초(CNN, Convolution Neural Network)",
            "author": "John",
            "category": "",
            "content": "  CNN 강좌는 여러 절로 구성되어 있습니다.      합성곱 신경망 기초(CNN, Convolution Neural Network)          합성곱 신경망 기초 2(역전파, Backpropagation)        합성곱 신경망 기초 3(배치정규화, Batch Normalization)        합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)        합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)        합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)        합성곱 신경망 기초 7(EfficientNet, Rethinking Model Scaling for      Convolutional Neural Networks)        합성곱 신경망 기초 8(Data Augmentation, 데이터 증강)  CNN이란?  Convolution을 이용한 이미지 처리에 탁월한 성능을 보이는 인공신경망  이미지 경우 이동되었거나, 방향이 뒤틀렸거나 등 다양한 변형이 존재한다. 기존 MLP는 픽셀 값이 약간 달라져도 민감하게 영향을 받는다는 단점  데이터의 공간적 정보를 유지하면서 배열 데이터 정보를 다음 레이어로 보낼 수 있어서 이미지(RGB 채널의 3차원 배열) 분야에서 적극 활용  이미지의 특징을 뚜렷하게 검출하기 때문에 이미지 분류에서 높은 성능CNN에서는 필터를 이용한 Convolution연산을 반복적으로 진행하면서 이미지의 특징을 검출하기 때문에 생각보다 구조가 간단합니다. 다음의 세 가지 layer를 기억하시면 됩니다.  Convolution layer : 특징 추출(feature extraction)  Pooling layer : 특징 추출(feature extraction)  Fully-connected layer : 분류(classificaiton)[ 학습 내용 ]  필터 (커널)  패딩, 스트라이드  Pooling  ReLu 활성화 함수  Fully-Connected layer필터(커널)  커널(kernel)이라고도 불리며 이미지의 특징을 찾아내기 위한 공용 파라미터  필터 통과 이미지는 특성값을 가지고 있어 feature map 또는 activation map 라고함  이미지 픽셀 값은 Convolution 연산에 의해 변환되고 이 과정에서 색상, 선, 형태, 경계 등의 특징(feature)이 뚜렷해짐  필터가 많을수록 더 많은 이미지 특성을 추출하며, 컨볼루션 연산이 진행하면 할수록 이미지 크기는 작아지고 채널 수는 증가패딩, 스트라이드컨볼루션 연산을 계속할 경우, 이미지 크기가 작아져 어떻게 될까요?연산할 수 있는 픽셀이 없어 더 이상 훈련할 수 없게 됩니다.패딩 (Padding)  Network가 깊어지면 이미지 크기가 무한정 작아지는 것을 막기 위해 패딩이 존재  이미지 테두리에 일정 값(0 또는 1)을 넣어주는 작업▶ 패딩 효과① 합성곱 연산을 할 때마다 이미지 축소 문제 발생 → 연산 결과 실제 입력된 이미지와 같은 크기 출력② 테두리에 위치한 픽셀은 필터 결과 단 한번만 사용 → 패딩으로 연산 두번 진행(테두리 이미지 정보 가져옴)스트라이드 (Stride)  이미지에 필터를 적용하는 간격  스트라이드 값을 크게 주면 이동 간격이 넓어져 출력 데이터의 크기가 작아짐  패딩과 다르게 스트라이드는 출력데이터의 크기를 축소시키는 역할풀링  Pooling layer는 대부분 convolutional layer 바로 다음에 위치해 공간(spatial size)을 축소  채널 크기는 고정되며 입력 데이터의 크기가 축소되고 학습하지 않기 때문에 파라미터 수가 줄어들어 오버피팅(Overfitting) 방지오버피팅(Overfitting) : 모델이 훈련 데이터에만 잘 맞춰진 경우로 결과가 훈련 데이터 정확도는 높지만 새롭게 입력 받는 테스트 데이터의 정확도는 낮아 모델 성능이 떨어지는 현상풀링(Pooling)에는 맥스 풀링(Max Pooing)과 평균 풀링(Average Pooling)이 존재① 맥스 풀링(Max Pooing) : 대상 이미지 영역에서 최대값을 구함 ② 평균 풀링(Average Pooling) : 대상 이미지 영역에서 평균값을 구함※ stride =2 를 특징으로 함[CNN 배열 공식]ReLu  ReLu(Rectified Linear Unit) 활성화 함수는 비선형성 함수로 기본 선형 특성을 나타내는 layer에 비선형성을 증가  ReLu 함수의 범위는 R(z)=max(0, z) 양수이기 때문에 vanishing gradient 문제점을 극복하고 학습 속도와 성능을 향상시켜 CNN에서 주로 사용되는 활성화 함수Fully-Connected layer  CNN 마지막에서 분류(Classification)를 결정하는 단계  flatten : 각 레이어를 1차원 벡터로 변환  fully-conneced layer : 1차원 벡터로 변환된 레이어를 하나의 벡터로 연결 (각 층의 노드들은 하나로 연결)마지막으로 Softmax 함수를 이용해 가장 확률이 높은 class를 output으로 분류참조 문헌https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-convolutional-neural-networks#layerhttps://seongkyun.github.io/study/2019/01/25/num_of_parameters/http://taewan.kim/post/cnn/",
        "url": "/cnn-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



      <!-- Previous/next page links - displayed on every page -->
      

      <!-- The footer at the very bottom of the screen -->
      <footer class="site-footer outer">
        <div class="site-footer-content inner">
          <section class="copyright">
            <a href="http://localhost:4000/">John's IT Blog</a>
            &copy; 2022
          </section>
          <section class="poweredby">
            Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
            <a href="https://pages.github.com/" target="_blank" rel="noopener"
              >GitHub Pages</a
            >
            using
            <a
              href="https://github.com/jekyllt/jasper2"
              target="_blank"
              rel="noopener"
              >Jasper2</a
            >
          </section>
          <nav class="site-footer-nav">
            <a href="/">Latest Posts</a>
             
            <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
          </nav>
        </div>
      </footer>
    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
      <a class="subscribe-overlay-close" href="#"></a>
      <div class="subscribe-overlay-content">
        
        <h1 class="subscribe-overlay-title">Search John's IT Blog</h1>
        <p class="subscribe-overlay-description">lunr.js를 이용한 posts 검색</p>
        
<span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

      </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>
      $(document).ready(function () {
        $("pre code").each(function (i, block) {
          hljs.highlightBlock(block);
        });
      });
    </script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
      src="https://code.jquery.com/jquery-3.2.1.min.js"
      integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
      crossorigin="anonymous"
    ></script>
    <script
      type="text/javascript"
      src="/assets/js/jquery.fitvids.js"
    ></script>
    <script
      type="text/javascript"
      src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"
    ></script>

    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    

    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
     <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>
 

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->
  </body>
</html>
