<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- Custom CSS -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- Syntax CSS -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="AI & Frontend Developer" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="John's IT Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="AI & Frontend Developer" />
    <meta property="og:url" content="http://localhost:4000/search" />
    <meta property="og:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="AI & Frontend Developer" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="John's IT Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "John's IT Blog",
        "logo": "http://localhost:4000/"
    },
    "url": "http://localhost:4000/search",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/search"
    },
    "description": "AI & Frontend Developer"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/">John's IT Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-ai" role="menuitem"><a href="/tag/data/">Data</a></li>
    <li class="nav-frontend" role="menuitem"><a href="/tag/frontend/">Frontend</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "js-basic-7": {
        "title": "클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)경계 다루기 😎min-max👍  최소값과 최대값을 다룬다.  포함 여부를 결정해야 한다(이상-초과 / 이하-미만)  혹은 네이밍에 최소값 최대값 포함 여부를 작성한다.function genRandomNumber(min, max) {return Math.floor(Math.random() * (max - min + 1)) + min;}const MIN_NUMBER = 1;const MAX_NUMBER = 45;// MAX_NUMBER_LIMIT 초과// MAX_IN_NUMBER 포함const result = genRandomNumber(MIN_NUMBER, MAX_NUMBER);console.log(result);const MAX_AGE = 20;function isAdult(age) {// 최소값, 최대값 (포함되는지 vs 안되는지)// 이상, 초과 vs 이하, 미만if(age&gt;=20) {return;}Begin-End👍  경계를 포함하지만 제외하는 경우  달력, 에어비엔비와 같은 출국,입국일을 생각하면 쉽다.function reservationDate(beginDate, endDate) {// ....some code    return;}reservationDate(\"YYYY-MM-DD\", \"YYYY-MM-DD\");First-Last👍  포함된 양 끝을 의미한다.  포함되어 있는 규칙이나 연속성에 대해 보장 X  부터 ~~~ 까지const students = [\"A\", \"B\", \"C\"];function getStudents(first, last) {// ...some code}getStudents(students[0], students[2]);Prefix(접두사) - Suffix(접미사)의 중요성 (규칙) 👍  JS의 prefix getter, setter  React usePrefix (기본 Hooks, useState,useEffect …)  jQuery prefix $매개변수 순서가 경계 👍호출하는 함수의 네이밍과 인자의 순서의 연관성을 고려한다.  매개변수를 2개가 넘지 않도록 만든다.  arguments, rest parameter 사용  랩핑하는 함수 사용  매개변수를 객체로 담아서 넘긴다function someFunc(someArg1, someArg2, someArg1, someArg2) {}function getFunc(someArg3, someArg4) {// 많이 쓰는 매개변수 일 경우 이렇게 들고온다.someFunc(undefined, undefined, someArg3, someArg4);}function someFunc2({ someArg1, someArg2, someArg1, someArg2 }) {}getRandomNumber(1, 50);getDates(\"2021-01-01\", \"2021-12-31\");shuffleArray(1, 5);",
        "url": "/js-basic-7"
    }
    ,
    
    "js-basic-6": {
        "title": "클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)타입 다루기 😎형변환 주의하기👍http://dorey.github.io/JavaScript-Equality-Table/  느슨한 검사 =&gt; 암묵적 형 변환console.log(\"1\" == 1);console.log(1 == true);console.log(0 == false);console.log(11 + \" 문자와 결합\"); // '11 문자와 결합'console.log(!!\"문자열\"); // trueconsole.log(!!\"\"); // falseparseInt(\"9.999\", 10); // 9 (10진수)// 명시적 변환 (옳은 예)console.log(String(11 + \" 문자와 결합\")); // '11 문자와 결합'console.log(Boolean(!!\"문자열\")); // trueconsole.log(Boolean(!!\"\")); // false사용자가 형변환시 명시적 변환자바스크립트 엔진이 평가시 암묵적 형변환▻ 타입 변환시 명시적 변환을 해주어야 한다.isNaN👍console.log(Number.MAX_SAFE_INTEGER); //9007199254740991console.log(Number.isInteger); //ƒ isInteger() {}is Not A Number =&gt; 숫자가 아니다.isNaN(123) // false =&gt; 숫자가 맞다.typeof 123 === 'number' // trueisNaN(123+'테스트') // true =&gt; 숫자가 아니다.Number.isNaN(123+ '테스트') // false =&gt; 숫자가 맞다.ES2015+ 이후 버전  isNaN ▻ 느슨한 검사  Number.isNaN ▻ 엄격한 검사",
        "url": "/js-basic-6"
    }
    ,
    
    "js-basic-5": {
        "title": "클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)타입 다루기 😎undefined &amp; null 👍console.log(null); // nullconsole.log(!null); // trueconsole.log(!!null); // falseconsole.log(null === false); // false// null =&gt; math =&gt; 0console.log(null + 123); // 123// 선언했지만 정의되지 않고 할당 Xlet varb;console.log(varb); //undefinedconsole.log(typeof varb); // undefinedconsole.log(varb + 10); // NaNconsole.log(!undefined); // trueconsole.log(undefined == null); // trueconsole.log(undefined === null); // falseconsole.log(!undefined === !null); // true차이점      undefined, null =&gt; 값이 없거나(명시적 표현) 정의되지 않음    undefined ▻ NaN ▻ type undefined  null ▻ 0 ▻ type Objecteqeq 줄이기 (동등 연산자 ==)👍equality (==)  형변환(type casting)이 일어난다.console.log(1 === 1); // trueconsole.log(1 === \"1\"); // true//Strict equality(===)console.log(1 === 1); // trueconsole.log(1 === \"1\"); // falseconst ticketNum = document.querySelector(\"#ticketNum\");console.log(ticketNum.value); // '0'console.log(ticketNum.value &gt; 1000); // falseconsole.log(ticketNum.value === 0); // falseconsole.log(ticketNum.value == 0); // 위험 협업시 알아듣기 어렵다.// 옳은 예console.log(Number(ticketNum.value) === 0); // trueconsole.log(ticketNum.valueAsNumber == 0); // true",
        "url": "/js-basic-5"
    }
    ,
    
    "js-basic-4": {
        "title": "클린코드 자바스크립트 2-1 타입 다루기(타입 검사)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)타입 다루기 😎타입 검사👍  PRIMITIVE vs REFERENCE  Recference 는 객체 (Array, function, Date …)  typeof 로 감별해내기 어렵다.function myFunction() {}class MyClass {}const str = new String(\"문자열\");typeof \"문자열\"; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof 123; // 'number'typeof Symbol(); // 'symbol'typeof myFunction; // 'function'typeof MyClass; // 'functiontypeof str; // 'undefined'가장 치명적인 문제 😥자바 스크립트가 인정한 오류typeof null; // 'object'  자바스크립트는 동적으로 변하는 언어 ▻ 타입 동적  객체의 프로토타입 체인을 확인하는 법 (객체 확인에 용이)function Person(name, age) {  this.name = name;  this.age = age;}const p = {  name: \"test\",  age: 85,};const poco = new Person(\"poco\", 99);poco instanceof Person; // truep instanceof Person; // falseconst arr = [];const func = function () {};const date = new Date();arr instanceof Array; // truefunc instanceof Function; // truedate instanceof Date; // true// 최상위에 Object 가 있으므로 truearr instanceof Object; // truefunc instanceof Object; // truedate instanceof Object; // trueObject.prototype.toString.call(arr); // '[object Array]'Object.prototype.toString.call(func); // '[object Function]'Object.prototype.toString.call(date); // '[object Date]'  자바스크립트는 동적인 타입을 가진 언어이다.  타입 검사가 어려움 하나하나 잘 찾아가면서 검사 해야한다.  어떠한 부분이 주의해야할지 외우는게 아닌 하나하나 잘 찾아서 검사해야한다!  Primitive vs Reference / typeof instanceof 등Solution 🌼아래와 같은 내용으로 Stack Overflow , Google 최신 검색해보며 타입 검사  javascript is function  javascript is Array  javascript is String}",
        "url": "/js-basic-4"
    }
    ,
    
    "js-basic": {
        "title": "클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)변수 다루기 😎var를 지양하자. 👍  let &amp; const 사용var : 함수 스코프let &amp; const : 블록 단위 스코프 + Temporary Dead Zone  var는 변수 선언 및 할당 재사용 가능    var name = \"이름\";console.log(name);var name = \"이름2\";console.log(name);        호이스팅으로 인해, 변수 선언이 먼저 가기 때문에 아래와 같이 undefined가 나온다.    console.log(name2); // undefinedvar name2 = \"hello\";console.log(name2);        let (변수 선언 및 재할당 가능)    let name = \"이름\";name =\"이름2\";        const (변수 선언시 할당해주어야 한다)    const name = \"이름;            function scope &amp; block scope 👍    var는 Function 단위이므로 지역에서 할당한 변수가 전역까지 오염된다.var global = \"전역\"if (global ===\"전역) {    var global = '지역'    console.log(global); // 지역}console.log(global) // 지역  let는 block 단위이므로 전역에 오염되지 않는다.let global = \"전역\"if (global ===\"전역) {    var global = '지역'    console.log(global); // 지역}console.log(global) // 전역  let보다 const를 사용하는 것이 좋다.  const는 재할당 불가만 기억하면 된다.객체 조작은 문제 없음const person = {    name : \"john\",    age : 27,}// Error 발생(재할당 불가)// person = {//   name : \"john2\",//    age : 30,person.name = \"john2\";person.age = 30;}배열 조작시에도 문제 없음const numList = [1,2,3,4,5];numList.push(1)",
        "url": "/js-basic"
    }
    ,
    
    "js-basic-3": {
        "title": "클린코드 자바스크립트 1-3 변수 다루기(호이스팅)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)변수 다루기 😎호이스팅 👍  런타임시 선언과 할당이 분리되는 것  런타임시 선언이 최상단으로 끌어올려진다.  var 경우, 할당이 제대로 되지 않았을 때, 선언했다면 undefinedvar global = 0;function outer(){    console.log(global); // undefined    var global = 5;    function inner() {        var global = 10;        console.log(global); // 10    }}    inner();    global = 1;    console.log(global); // 1outer();function duplicatedVar() {    var a;    console.log(a); // undefined    var a = 100;    console.log(a); // 100}console.log(duplicatedVar()); // undefinedvar sum;console.log(typeof sum); // functonconsole.log(sum); // 3function sum() {    return 1+2;}  const를 사용해 함수를 만들고 할당하는 방식(함수 표현식)을 추천    console.log(sum()); //errorconst sum = () =&gt; {  return 1+2;}      호이스팅 문제 😫  코드 작성시 예측과 실행이 다른 문제가 생긴다.  var 사용 X &gt; let,const 지향  함수 조심 &gt; 함수 표현식 사용",
        "url": "/js-basic-3"
    }
    ,
    
    "js-basic-2": {
        "title": "클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)",
            "author": "John",
            "category": "",
            "content": "Clean Code JS 강좌는 여러 절로 구성되어 있습니다.     클린코드 자바스크립트 1-1 변수 다루기(let &amp; const 사용, function scope &amp; block scope)     클린코드 자바스크립트 1-2 변수 다루기(전역 공간 사용 최소화,임시 변수 제거하기)    클린코드 자바스크립트 1-3 변수 다루기(호이스팅)    클린코드 자바스크립트 2-1 타입 다루기(타입 검사)    클린코드 자바스크립트 2-2 타입 다루기(undefined &amp; null, eqeq 줄이기)    클린코드 자바스크립트 2-3 타입 다루기(형변환 주의하기, isNaN)    클린코드 자바스크립트 3-1 경계 다루기(min-max,begin-end,first-last,접두사와 접미사, 매개변수 순서가 경계)변수 다루기 😎전역 공간 사용 최소화 👍누구에게 들어보았나요?  경험  누군가 혹은 자바스크립트 생태계  강의 혹은 책  회사 혹은 책  Lint전역 (최상위)  Window (Web Browser)  global (NodeJS)ex) index.js 와 index2.js를 웹이 같이 불러올 때,  아래와 같이, setTimeout 에러 없이 동작 불가  Web API이기 때문에 에러가 나오지 않는다.// index.js)var globalVar = 'global';console.log(globalVar);console.log(window.globalVar);var setTimeout = 'setTimeout';// 에러 없이 동작 불가,// Web API이기 때문에 에러가 나오지 않는다.function setTimeout() {    console.log('function)}// index2.js)console.log(globalVar) // 사용 가능setTimeout(() =&gt;{console.log('1초')};,1000);  index 라는 전역 변수가 남는다.  let 이나 const 로 바꾸어주어야함for(var index=0; index &lt; array.length; index++) {    const element = array[index];}//전역 공간을 더럽히면 왜 안될까?🤦‍♂️  어디서나 접근 가능하다.  스코프 분리 위험(사람이 생각하기에 분리했지만 런타임 환경에서는 분리하지 못했다.)전역 공간을 더럽히지 않는 방법 🌻  전역 변수 X  지역 변수 O  window, global을 조작 X  const, let OK  IIFE, Module, Closure , Scope 분리임시 변수 제거하기  임시 변수 혹은 객체를 어떻게 제거해야 메모리 공간을 차지하지 않는다.const $ = (value) =&gt; {    document.querySelector(value);}// 안 좋은 예 function getElements1() {     임시 객체 CRUD     const result = {        title : $('.title'),        text : $('.text'),        value : $('.value'),    };    return result; }// 좋은 예 function getElements2() {    return {        title : $('.title'),        text : $('.text'),        value : $('.value'),    }; }  추가적인 스펙을 요구할 때 (날짜에 대한 요구 사항)  내가 할 수 있는 것은 2가지 방식이 있다.          함수 추가      함수 수정 (문제가 생길 수 있다.)        함수 수정 예시    // 잘못된 예function getDateTime(targetDate) {  let month = targetDate.getMonth();  let day = targetDate.getDay();  let hour = targetDate.getHour();  month = month &gt;= 10? month : '0' + month;  day = day &gt;= 10? month : '0' + day;  hour = hour &gt;= 10? hour : '0' + hour;  return {       month, day, hour  };}        함수 추가 예시          임시 변수의 유혹을 벗어나야 한다. (추상화 과정을 거친다.)      함수는 하나의 역할만 하도록 한다.      // 좋은 예function getDateTime(targetDate) {    const month = targetDate.getMonth();    const day = targetDate.getDay();    const hour = targetDate.getHour();    return {    month : month &gt;= 10? month : '0' + month;    day  : day &gt;= 10? month : '0' + day;    hour : hour &gt;= 10? hour : '0' + hour;    }function getDateTime1() {    const currentDateTime = getDateTime(new Date());    return {    month : computedKrDate(currentDateTime.month) +'분 전'    day  : computedKrDate(currentDateTime.day) +'분 전'    hour : computedKrDate(currentDateTime.hour) +'분 전'    }}function genRandomNumber(min,max) {    const randomNumber =Math.floor(Math.random() * (max +1) + min);    return randomNumber;}임시 변수를 제거해야 하는 이유?  명령형으로 가득한 Logic이 나온다.  어디서 어떻게 잘못되었는지 디버깅이 어렵다.  추가적인 코드를 작성하고 싶은 유혹에 빠진다. (함수는 하나의 기능)Solution 🌼  함수 나누기  고차 함수(map,filter,reduce)  바로 반환  선언형 프로그래밍",
        "url": "/js-basic-2"
    }
    ,
    
    "cnn-basic-6": {
        "title": "합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)ResNet  ILSVRC 2015 우승 (3.6% Top 5 Error)한 모델이며 Deep Residual Learning 이라고도 부른다.  152개의 Layer 구조이며 8배 깊은 Layers를 가졌음에도 불구하고 실행 시간이 VGGNet보다 빠르다.  이 모델은 일반적인 레이어만 깊은 모델들과 비교했을 때 성능이 좋을 뿐만 아니라 학습 속도도 더 빠르다.Introduction  VGGNet 논문에서 CNN 의 레이어가 깊어질수록 성능이 더 좋다는 것을 확인할 수 있었다.  하지만 레이어가 너무 깊어지면 Vanishing/Exploding gradient, 그리고 degradation problem 크게 이 두 가지 문제점에 봉착한다.  우선 Vanishing/Exploding gradient 같은 경우에는 레이어 사이에 batchNorm 을 적용해주면 해결할 수 있다.Degradation Problem 이란 정확도가 어느 순간부터 정체되고 레이어가 더 깊어질수록 성능이 더 나빠지는 현상을 의미한다.이 논문에서는 Residual Learning 을 통해 Degradation Problem 을 해결하는 방법을 제시한다.  간단하게 input 을 x, input이 통과하는 Function 을 F(x), 그리고 Output 을 H(x) 이라고 가정해보자. F(x) = H(x) - x 를 최소화시키는 Residual mapping으로 H(x)를 재정의한다.   Residual Learning 에서는 F(x) 를 H(x) - x 라고 define 해 주었다. 원래 Output H(x) 에서 자기 자신인 x 를 빼주기 때문에 ‘Residual Learning’ 이라는 이름을 가지게 된다.   또 x 가 이 F(x) 를 통과한 이후에, 이 값은 자기 자신인 x 와 더해주고, Layer를 Skip해서 더해주기에 ‘Skip Connections’ 이라고 부른다. 이 Residual Block 을 통과하고 나면 최종적인 값은 F(x) + x 가 나오게 된다.  F(x) 와 x 를 직접적으로 더해주기 위해선 F(x) 와 x 가 서로 같은 Dimension 이어야 한다. 일반적으로 F(x) 와 이전의 input x가 채널수가 같다면 별다른 조치를 취해주지 않아도 그냥 더해주면 된다.  하지만 Channel 개수가 달라지거나 MaxPool 등에 의해서 x 의 크기가 달라질 때, padding 이나 별다른 Ws 를 곱해주어서 사이즈를 매칭 시켜주는 것이 중요하다.ResNet Architecture  ResNet 의 기본 구조는 VGGNet-34 을 따른다. 위 그림을 보면 VGG-34 과 모델 구성은 같은데, 레이어 두개마다 Skip Connection 을 해준다는 것을 볼 수 있다.  중간에 점선으로 표시된 Skip Connection 은 x 와 F(x) 의 Dimension 이 달라져서 따로 맞춰줘야 되는 Skip Connection 들을 의미한다.Deeper Bottleneck Architectures  네트워크의 깊이가 50 을 넘어가면, 제아무리 ResNet을 이용하고 3x3 필터만 사용한다 할지라도 Training 시간이 매우 길어질 수 있다. 따라서 이 경우엔 원래 모델 구조에서 약간의 수정이 필요하다.  3x3 필터를 두 번 사용하는 대신, 1x1 -&gt; 3x3 -&gt; 1x1 필터들을 사용하는 구조를 만든다. 이렇게 수정한 구조는 Dimension 의 크기를 줄일 뿐만 아니라 시간 복잡도도 줄이는 효과를 볼 수 있다.ExperimentsResNet 은 1000개의 클라스로 이루어진 ImageNet 2012 데이터셋으로 training  위 그래프에서 왼쪽 그림은 Plain Network 의 18, 34 Layer, 오른쪽 그림은 ResNet 의 18, 34 layer 의 Loss 과정이다.  우선 왼쪽 그림에서는 Degradation Problem 이 보이는 것을 확인할 수 있다. 34-Layer 네트워크가 18-layer 보다 Loss 가 높기 때문이다.  반면 ResNet 같은 경우엔 34-Layer 가 Loss 가 더 낮게 나오는 것을 확인할 수 있다. Degradation Problem 이 해결됐음을 보여주는 그래프이다.  위 표에서는 더 깊은 ResNet 들의 성능을 보여준다. 레이어가 깊어지면 깊어질수록 error 는 줄어드는 경향성을 볼 수 있고, 110 개의 레이어가 있을 때 가장 적은 에러가 나온다.  하지만 그렇다고 너무 깊어지면, 예를 들어 1000 개 이상의 레이어가 존재할 때는 오버피팅으로 인하여 성능이 더 얕은 모델들보다 더 안 좋게 나온다.참조 문헌[1] He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition (pp. 770-778).https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf",
        "url": "/cnn-basic-6"
    }
    ,
    
    "cnn-basic-5": {
        "title": "합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)VGGNet  ILSVRC 2014 대회에서 2등을 차지한 Karen Simonyan과 Andrew Zisserman이 만든 CNN 모델  ILSVRC는 ImageNet Large Scale Visual Recognition Challenge의 약자로, 2010년에 시작된 이미지 인식(Image Recognition) 경진대회VGG-16 Architecture  13 Convolution Layers + 3 Fully-connected Layers  3x3 convolution filters  stride: 1 &amp; padding: 1  2x2 max pooling (stride : 2)  ReLUConfiguration  Input Size RGB 224x224, 복수의 Convolution layer, Max-Pooling층이 반복되는 구조이며 최종단에는 FC layer으로 구성되어 있다.3x3 필터 사용 (Why use smaller filters?)  VGG 모델 이전 Convolutional Network를 활용하여 이미지 분류에서 좋은 성과를 보였던 모델들은 비교적 큰 Receptive Field를 갖는 11x11필터나 7x7 필터를 포함  그러나 VGG 모델은 오직 3x3 크기의 작은 필터만 사용했음에도 이미지 분류 정확도를 비약적으로 개선  파라미터 수를 줄이고 Layer를 다층 쌓아서 모델의 전체 Depth를 깊게 만들기 위해서이다.  Input Size가 7x7이며, 3x3의 Output Size를 도출해내야 한다고 가정하자, 이때 Filter Size가 3x3이라면 총 두 차례의 Convolution을 진행해야 한다.  반면 5x5의 Filter Size로는 단 한 번의 Convolution으로 동일한 사이즈의 Feature Map을 산출한다. 3x3 Filter로 세 차례 Convolution 하는 것은 7x7 Filter로 한 번 Convolution 하는 것과 대응된다.  즉, 3x3 Filter 3개는 7x7 Filter 하나와 동일한 Receptive Field (= Filter가 한 번에 볼 수 있는 입력 이미지의 Spatial Area) 를 가지면서도 더 깊은 레이어를 쌓을 수 있게 하는 것이다.  이처럼 Layer 수가 늘어나면 이미지 특성에 비선형성을 더 추가할 수 있기 때문에(Deeper, more non-linearities), Filter를 통해 추출한 Feature가 점점 유용해지는 이점을 얻게 된다.필터의 크기가 작으면 파라미터 수도 적어진다(Smaller filters, fewer parameters)  3x3 Filter에는 9개의 파라미터가 있다. 이때 Depth를 C라고 한다면 3 x 3 x C 개의 파라미터가 있고, 여기에 출력되는 Feature Map의 개수(=입력 Depth)를 곱하면 각 레이어 당 3x3xCxC의 파라미터를 가지게 된다. 만약 Layer가 3개라면, 총 파라미터는 3 * (32C2)개이다.  반면 7x7 Filter의 경우 7x7xCxC개의 파라미터 수가 있을 것이다. 레이어를 더 적게 쌓았음에도 파라미터 수가 많은 것을 확인할 수 있다.  여기서 파라미터(weight) 수가 적다는 것은 어떤 의미를 가질까? CNN에서 가중치는 모두 훈련이 필요한 것들이므로, 파라미터 수가 적을 수록 학습 속도가 빨라진다는 이점을 얻을 수 있다.결론  VGGNet은 3x3의 작은 필터를 모든 Conv 레이어에 사용하였다.  작은 필터를 사용함으로써 더 많은 ReLU함수를 사용할 수 있고 더 많은 비선형성을 확보할 수 있었다.  VGGNet의 A~E까지 각각의 다른 모델이 아니라 학습의 단계부터 알 수 있듯, 업그레이드된 모델이다.  위와 같은 특징들로 AlexNet보다 2배 이상 깊은 네트워크이며 좋은 성능을 가진 모델을 만들어 낼 수 있었다.  줄였음에도 파라미터의 수가 엄청나게 많기 때문에 학습 시간이 오래 걸린다참조 문헌https://arxiv.org/pdf/1409.1556.pdf",
        "url": "/cnn-basic-5"
    }
    ,
    
    "cnn-basic-4": {
        "title": "합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)가중치 초기화가중치가 중요한 이유  Overfitting-Underfitting 문제가 발생해 제대로 학습이 되지 않을 수 있다.  그래디언트 손실(Vanishing Gradient)와 폭주(Exploding)문제가 발생한다.  지역 최적화(Local Optimization)에 실패해 Local mnimum에 수렴하기도 한다.  즉, 같은 모델을 훈련시키더라도 가중치가 어떤 초기 값을 갖느냐에 따라서 모델 훈련 결과가 달라진다.  가중치 값이 0일 경우, 학습이 불가능하다.  가중치 값을 같은 값으로 할 경우, 1개 신경망에 학습시키는 것과 동일  평균 0 ,1보다 작은 표준편차 분포를 사용한다.1) Sigmoid, 정규분포  표준편차가 크기 때문에 학습이 반복될 수록 0,1로 치우치는 문제가 발생2) 1)에서 표준편차를 줄였을 경우  Sigmoid 그래디언트 최댓값이 0.25이므로 현상을 완화할 수는 있지만 0.5로 몰리는 현상“더 나은 방법을 찾아보자”LeCun Initialization  CNN LeNet 창시자 LeCun이 도입  정규분포, Uniform 분포를 따르는 방법 2가지가 있다.Xavier Initialization  이전 노드와 다음 노드 개수에 의존하는 방법  비선형함수(ex. sigmoid, tanh)에서 효과적인 결과He Initialization  Relu 활성화 함수 사용시, Xavier 설정이 비효율적인 결과를 가져온다.(평균, 표준편차 0으로 수렴)  최근 대부분 모델에서 He 초기화를 사용한다.⭐️ 최근 Deep CNN 모델들은 Gaussian Distribution 초기화 방법 사용참조 문헌https://kharshit.github.io/blog/2018/12/28/why-batch-normalizationhttps://reniew.github.io/13/https://wooono.tistory.com/227",
        "url": "/cnn-basic-4"
    }
    ,
    
    "cnn-basic-3": {
        "title": "합성곱 신경망 기초 3(배치정규화, Batch Normalization)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)배치 정규화깊은 신경망일 수록 같은 Input 이라도 가중치가 조금이라도 다르다면 완전히 다른 결과를 가져올 수 있다.“각 층이 활성화를 적당히 퍼뜨리도록 강제로 해보자”  배치란? 신경망 학습시, 전체 데이터를 한 번에 학습시키지 않고, 조그만 단위로 분할해서 학습 시키는 것.  배치 정규화란? 배치 단위로 정규화 하는 것.[배치 정규화 알고리즘]  엡실론은 분모가 0 이 되는 것을 막기 위한 아주 작은 숫자(1e-5~7)  정규화 이후, 배치 데이터들을 scale(감마(γ)), shift(베타(β)) 를 통해 새로운 값으로 바꾼다.  데이터를 계속 정규화 하게 되면, 활성화 함수의 비선형 성질을 잃게 되는 문제 발생      아래 그림과 같이 Sigmoid 함수 경우, 입력 값이 N(0, 1) 이라면, 95% 의 입력 값은 Sigmoid 함수 그래프의 중간 (x = (-1.96, 1.96) 구간)에 속하게 된다.    감마(γ), 베타(β)를 통해 활성함수로 들어가는 값의 범위를 변환하여 비선형 성질을 보존  감마(γ), 베타(β) 값은 학습 가능한 변수, 역전파를 통해서 학습⭐배치 정규화 효과⭐  학습이 빠르게 진행(Epoch 수를 줄이는데 효과적)  Dropout 필요성 감소  더 높은 Learning rate 사용 가능  규제 효과 (과적합 방지)  그래디언트 손실(Vanishing Gradient)와 폭주(Exploding)문제 해결참조 문헌https://kharshit.github.io/blog/2018/12/28/why-batch-normalizationhttps://reniew.github.io/13/https://wooono.tistory.com/227",
        "url": "/cnn-basic-3"
    }
    ,
    
    "cnn-basic-2": {
        "title": "합성곱 신경망 기초 2(CNN, 역전파 Backpropagation)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)CNN foward pass  CNN은 필터가 입력데이터를 슬라이딩하면서 지역적 특징(feature)을 추출  이 특징을 최대값(Max Pooling)이나 평균값(Average Pooling)으로 압축해 다음 레이어로 전달  이런 과정을 반복해 분류 등 원하는 결과를 만들어내는 것이 CNN의 일반적인 구조[Cross-Correlation][Convolution]K(−m,−n) == K(m,n)일 때, Convolution 과 Cross-Correlation이 동일하다.  𝑥𝑖𝑗 는 각각 입력값의 𝑖번째 행, 𝑗번째 열의 요소  3x3 행렬, 2x2 필터(커널), 스트라이드 1  이후 conv 레이어에 최대값이나 평균값을 취해서 정보를 압축(pooling)되어 2x2 행렬이 2x1 벡터로 바뀐다.CNN backward pass[Average Pooling 레이어의 그래디언트 전파 과정]  CNN 역전파 공식 (가중치 변화에 따른 오차 변화량)  HxW feature Map, k1 x k2 kernel 일 때, output은 (H-k1+1),(W-k2+1)  현재 지점(x)의 그래디언트 식  최종 식[Average Pooling]  바로 뒤 레이어로부터 전파된 그래디언트가 𝑑1, 𝑑2  현재 지점의 그래디언트는 미분의 연쇄법칙(chain rule)에 의해 흘러들어온 그래디언트(d)에 로컬 그래디언트(w 혹은 x)를 곱한 것과 같음  Average Pooling을 하는 지점의 로컬 그래디언트는 1/𝑚[Max Pooling]  가장 큰 값이 속해 있는 요소의 로컬 그래디언트는 1, 나머지는 0[Convolution Layer]  𝑥11 은 forward pass 과정에서 2x2필터 가운데 빨간색(𝑤1) 가중치하고만 합성곱이 수행 되므로 역전파 때도 마찬가지로 딱 한번의 역전파가 일어남  Kapathy의 계산그래프 형태로 나타내면 𝑥11 의 그래디언트는 흘러들어온 그래디언트𝑑11에 로컬 그래디언트(𝑤1)를 곱해서 구할 수 있다.  마찬가지로 𝑤1 의 그래디언트는 흘러들어온 그래디언트 𝑑11에 로컬 그래디언트(𝑥11)를 곱해 계산  하지만 이렇게 하나하나 따져가면서 구하려면 식이 복잡하고 이해가 어렵다.  conv layer가 역전파를 할 때 약간의 트릭을 쓰면 조금 더 간단히 그래디언트를 구할 수 있다.간단한 방법  흘러들어온 그래디언트 행렬에(2x2 크기)을 conv layer를 만들 때 썼던 필터가 슬라이딩하면서 값을 구한다  필터 요소의 순서를 정반대로 바꿔 예컨대 빨-파-노-초 필터를 초-노-파-빨 필터로 바꿔서 그래디언트 행렬에 합성곱을 수행해주면 입력벡터(x)에 대한 그래디언트를 구할 수 있다.  필터의 그래디언트는 그래디언트 행렬 첫번째 요소인 𝑑11은 𝑥11, 𝑥12, 𝑥21, 𝑥22와 연결되어 있는 걸 확인할 수 있다. (영향을 끼치는 곳)흘러들어온 그래디언트(𝑑11, 𝑑12, 𝑑21, 𝑑22)에 로컬 그래디언트(x11, x12, x21, x22)를 곱한다.  각각의 로컬 그래다언트는 합성곱 필터 가중치로 연결된 입력값들이기 때문에 𝑑𝑤11은 𝑥11𝑑11+𝑥12𝑑12+𝑥21𝑑21+𝑥22𝑑22참조 문헌https://cs231n.github.io/optimization-2/https://www.jefkine.com/general/2016/09/05/backpropagation-in-convolutional-neural-networks/https://ratsgo.github.io/deep%20learning/2017/04/05/CNNbackprop/",
        "url": "/cnn-basic-2"
    }
    ,
    
    "cnn-basic": {
        "title": "합성곱 신경망 기초(CNN, Convolution Neural Network)",
            "author": "John",
            "category": "",
            "content": "CNN 강좌는 여러 절로 구성되어 있습니다.     합성곱 신경망 기초(CNN, Convolution Neural Network)     합성곱 신경망 기초 2(역전파, Backpropagation)    합성곱 신경망 기초 3(배치정규화, Batch Normalization)    합성곱 신경망 기초 4(가중치 초기화, Weight Initialization)    합성곱 신경망 기초 5(VGGNet, Very Deep Convolutional Network)    합성곱 신경망 기초 6(ResNet, Residual Learning for Image Recognition)CNN이란?  Convolution을 이용한 이미지 처리에 탁월한 성능을 보이는 인공신경망  이미지 경우 이동되었거나, 방향이 뒤틀렸거나 등 다양한 변형이 존재한다. 기존 MLP는 픽셀 값이 약간 달라져도 민감하게 영향을 받는다는 단점  데이터의 공간적 정보를 유지하면서 배열 데이터 정보를 다음 레이어로 보낼 수 있어서 이미지(RGB 채널의 3차원 배열) 분야에서 적극 활용  이미지의 특징을 뚜렷하게 검출하기 때문에 이미지 분류에서 높은 성능CNN에서는 필터를 이용한 Convolution연산을 반복적으로 진행하면서 이미지의 특징을 검출하기 때문에 생각보다 구조가 간단합니다. 다음의 세 가지 layer를 기억하시면 됩니다.  Convolution layer : 특징 추출(feature extraction)  Pooling layer : 특징 추출(feature extraction)  Fully-connected layer : 분류(classificaiton)[ 학습 내용 ]  필터 (커널)  패딩, 스트라이드  Pooling  ReLu 활성화 함수  Fully-Connected layer필터(커널)  커널(kernel)이라고도 불리며 이미지의 특징을 찾아내기 위한 공용 파라미터  필터 통과 이미지는 특성값을 가지고 있어 feature map 또는 activation map 라고함  이미지 픽셀 값은 Convolution 연산에 의해 변환되고 이 과정에서 색상, 선, 형태, 경계 등의 특징(feature)이 뚜렷해짐  필터가 많을수록 더 많은 이미지 특성을 추출하며, 컨볼루션 연산이 진행하면 할수록 이미지 크기는 작아지고 채널 수는 증가패딩, 스트라이드컨볼루션 연산을 계속할 경우, 이미지 크기가 작아져 어떻게 될까요?연산할 수 있는 픽셀이 없어 더 이상 훈련할 수 없게 됩니다.패딩 (Padding)  Network가 깊어지면 이미지 크기가 무한정 작아지는 것을 막기 위해 패딩이 존재  이미지 테두리에 일정 값(0 또는 1)을 넣어주는 작업▶ 패딩 효과① 합성곱 연산을 할 때마다 이미지 축소 문제 발생 → 연산 결과 실제 입력된 이미지와 같은 크기 출력② 테두리에 위치한 픽셀은 필터 결과 단 한번만 사용 → 패딩으로 연산 두번 진행(테두리 이미지 정보 가져옴)스트라이드 (Stride)  이미지에 필터를 적용하는 간격  스트라이드 값을 크게 주면 이동 간격이 넓어져 출력 데이터의 크기가 작아짐  패딩과 다르게 스트라이드는 출력데이터의 크기를 축소시키는 역할풀링  Pooling layer는 대부분 convolutional layer 바로 다음에 위치해 공간(spatial size)을 축소  채널 크기는 고정되며 입력 데이터의 크기가 축소되고 학습하지 않기 때문에 파라미터 수가 줄어들어 오버피팅(Overfitting) 방지오버피팅(Overfitting) : 모델이 훈련 데이터에만 잘 맞춰진 경우로 결과가 훈련 데이터 정확도는 높지만 새롭게 입력 받는 테스트 데이터의 정확도는 낮아 모델 성능이 떨어지는 현상풀링(Pooling)에는 맥스 풀링(Max Pooing)과 평균 풀링(Average Pooling)이 존재① 맥스 풀링(Max Pooing) : 대상 이미지 영역에서 최대값을 구함 ② 평균 풀링(Average Pooling) : 대상 이미지 영역에서 평균값을 구함※ stride =2 를 특징으로 함[CNN 배열 공식]ReLu  ReLu(Rectified Linear Unit) 활성화 함수는 비선형성 함수로 기본 선형 특성을 나타내는 layer에 비선형성을 증가  ReLu 함수의 범위는 R(z)=max(0, z) 양수이기 때문에 vanishing gradient 문제점을 극복하고 학습 속도와 성능을 향상시켜 CNN에서 주로 사용되는 활성화 함수Fully-Connected layer  CNN 마지막에서 분류(Classification)를 결정하는 단계  flatten : 각 레이어를 1차원 벡터로 변환  fully-conneced layer : 1차원 벡터로 변환된 레이어를 하나의 벡터로 연결 (각 층의 노드들은 하나로 연결)마지막으로 Softmax 함수를 이용해 가장 확률이 높은 class를 output으로 분류참조 문헌https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-convolutional-neural-networks#layerhttps://seongkyun.github.io/study/2019/01/25/num_of_parameters/http://taewan.kim/post/cnn/",
        "url": "/cnn-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">John's IT Blog</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search John's IT Blog</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            
<span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
